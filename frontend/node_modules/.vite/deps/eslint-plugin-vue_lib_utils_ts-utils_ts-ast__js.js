import {
  __commonJS,
  __require
} from "./chunk-34Z2WVG2.js";

// node_modules/eslint-plugin-vue/lib/utils/scope.js
var require_scope = __commonJS({
  "node_modules/eslint-plugin-vue/lib/utils/scope.js"(exports, module) {
    module.exports = {
      getScope
    };
    function getScope(context, currentNode) {
      const inner = currentNode.type !== "Program";
      const scopeManager = context.getSourceCode().scopeManager;
      let node = currentNode;
      for (; node; node = /** @type {ESNode | null} */
      node.parent) {
        const scope = scopeManager.acquire(node, inner);
        if (scope) {
          if (scope.type === "function-expression-name") {
            return scope.childScopes[0];
          }
          return scope;
        }
      }
      return scopeManager.scopes[0];
    }
  }
});

// node_modules/eslint-visitor-keys/dist/eslint-visitor-keys.cjs
var require_eslint_visitor_keys = __commonJS({
  "node_modules/eslint-visitor-keys/dist/eslint-visitor-keys.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var KEYS = {
      ArrayExpression: [
        "elements"
      ],
      ArrayPattern: [
        "elements"
      ],
      ArrowFunctionExpression: [
        "params",
        "body"
      ],
      AssignmentExpression: [
        "left",
        "right"
      ],
      AssignmentPattern: [
        "left",
        "right"
      ],
      AwaitExpression: [
        "argument"
      ],
      BinaryExpression: [
        "left",
        "right"
      ],
      BlockStatement: [
        "body"
      ],
      BreakStatement: [
        "label"
      ],
      CallExpression: [
        "callee",
        "arguments"
      ],
      CatchClause: [
        "param",
        "body"
      ],
      ChainExpression: [
        "expression"
      ],
      ClassBody: [
        "body"
      ],
      ClassDeclaration: [
        "id",
        "superClass",
        "body"
      ],
      ClassExpression: [
        "id",
        "superClass",
        "body"
      ],
      ConditionalExpression: [
        "test",
        "consequent",
        "alternate"
      ],
      ContinueStatement: [
        "label"
      ],
      DebuggerStatement: [],
      DoWhileStatement: [
        "body",
        "test"
      ],
      EmptyStatement: [],
      ExperimentalRestProperty: [
        "argument"
      ],
      ExperimentalSpreadProperty: [
        "argument"
      ],
      ExportAllDeclaration: [
        "exported",
        "source"
      ],
      ExportDefaultDeclaration: [
        "declaration"
      ],
      ExportNamedDeclaration: [
        "declaration",
        "specifiers",
        "source"
      ],
      ExportSpecifier: [
        "exported",
        "local"
      ],
      ExpressionStatement: [
        "expression"
      ],
      ForInStatement: [
        "left",
        "right",
        "body"
      ],
      ForOfStatement: [
        "left",
        "right",
        "body"
      ],
      ForStatement: [
        "init",
        "test",
        "update",
        "body"
      ],
      FunctionDeclaration: [
        "id",
        "params",
        "body"
      ],
      FunctionExpression: [
        "id",
        "params",
        "body"
      ],
      Identifier: [],
      IfStatement: [
        "test",
        "consequent",
        "alternate"
      ],
      ImportDeclaration: [
        "specifiers",
        "source"
      ],
      ImportDefaultSpecifier: [
        "local"
      ],
      ImportExpression: [
        "source"
      ],
      ImportNamespaceSpecifier: [
        "local"
      ],
      ImportSpecifier: [
        "imported",
        "local"
      ],
      JSXAttribute: [
        "name",
        "value"
      ],
      JSXClosingElement: [
        "name"
      ],
      JSXClosingFragment: [],
      JSXElement: [
        "openingElement",
        "children",
        "closingElement"
      ],
      JSXEmptyExpression: [],
      JSXExpressionContainer: [
        "expression"
      ],
      JSXFragment: [
        "openingFragment",
        "children",
        "closingFragment"
      ],
      JSXIdentifier: [],
      JSXMemberExpression: [
        "object",
        "property"
      ],
      JSXNamespacedName: [
        "namespace",
        "name"
      ],
      JSXOpeningElement: [
        "name",
        "attributes"
      ],
      JSXOpeningFragment: [],
      JSXSpreadAttribute: [
        "argument"
      ],
      JSXSpreadChild: [
        "expression"
      ],
      JSXText: [],
      LabeledStatement: [
        "label",
        "body"
      ],
      Literal: [],
      LogicalExpression: [
        "left",
        "right"
      ],
      MemberExpression: [
        "object",
        "property"
      ],
      MetaProperty: [
        "meta",
        "property"
      ],
      MethodDefinition: [
        "key",
        "value"
      ],
      NewExpression: [
        "callee",
        "arguments"
      ],
      ObjectExpression: [
        "properties"
      ],
      ObjectPattern: [
        "properties"
      ],
      PrivateIdentifier: [],
      Program: [
        "body"
      ],
      Property: [
        "key",
        "value"
      ],
      PropertyDefinition: [
        "key",
        "value"
      ],
      RestElement: [
        "argument"
      ],
      ReturnStatement: [
        "argument"
      ],
      SequenceExpression: [
        "expressions"
      ],
      SpreadElement: [
        "argument"
      ],
      StaticBlock: [
        "body"
      ],
      Super: [],
      SwitchCase: [
        "test",
        "consequent"
      ],
      SwitchStatement: [
        "discriminant",
        "cases"
      ],
      TaggedTemplateExpression: [
        "tag",
        "quasi"
      ],
      TemplateElement: [],
      TemplateLiteral: [
        "quasis",
        "expressions"
      ],
      ThisExpression: [],
      ThrowStatement: [
        "argument"
      ],
      TryStatement: [
        "block",
        "handler",
        "finalizer"
      ],
      UnaryExpression: [
        "argument"
      ],
      UpdateExpression: [
        "argument"
      ],
      VariableDeclaration: [
        "declarations"
      ],
      VariableDeclarator: [
        "id",
        "init"
      ],
      WhileStatement: [
        "test",
        "body"
      ],
      WithStatement: [
        "object",
        "body"
      ],
      YieldExpression: [
        "argument"
      ]
    };
    var NODE_TYPES = Object.keys(KEYS);
    for (const type of NODE_TYPES) {
      Object.freeze(KEYS[type]);
    }
    Object.freeze(KEYS);
    var KEY_BLACKLIST = /* @__PURE__ */ new Set([
      "parent",
      "leadingComments",
      "trailingComments"
    ]);
    function filterKey(key) {
      return !KEY_BLACKLIST.has(key) && key[0] !== "_";
    }
    function getKeys(node) {
      return Object.keys(node).filter(filterKey);
    }
    function unionWith(additionalKeys) {
      const retv = (
        /** @type {{
            [type: string]: ReadonlyArray<string>
        }} */
        Object.assign({}, KEYS)
      );
      for (const type of Object.keys(additionalKeys)) {
        if (Object.prototype.hasOwnProperty.call(retv, type)) {
          const keys = new Set(additionalKeys[type]);
          for (const key of retv[type]) {
            keys.add(key);
          }
          retv[type] = Object.freeze(Array.from(keys));
        } else {
          retv[type] = Object.freeze(Array.from(additionalKeys[type]));
        }
      }
      return Object.freeze(retv);
    }
    exports.KEYS = KEYS;
    exports.getKeys = getKeys;
    exports.unionWith = unionWith;
  }
});

// node_modules/@eslint-community/eslint-utils/index.js
var require_eslint_utils = __commonJS({
  "node_modules/@eslint-community/eslint-utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var eslintVisitorKeys = require_eslint_visitor_keys();
    function getInnermostScope(initialScope, node) {
      const location = node.range[0];
      let scope = initialScope;
      let found = false;
      do {
        found = false;
        for (const childScope of scope.childScopes) {
          const range = childScope.block.range;
          if (range[0] <= location && location < range[1]) {
            scope = childScope;
            found = true;
            break;
          }
        }
      } while (found);
      return scope;
    }
    function findVariable(initialScope, nameOrNode) {
      let name = "";
      let scope = initialScope;
      if (typeof nameOrNode === "string") {
        name = nameOrNode;
      } else {
        name = nameOrNode.name;
        scope = getInnermostScope(scope, nameOrNode);
      }
      while (scope != null) {
        const variable = scope.set.get(name);
        if (variable != null) {
          return variable;
        }
        scope = scope.upper;
      }
      return null;
    }
    function negate0(token) {
      return !this(token);
    }
    function negate(f) {
      return negate0.bind(f);
    }
    function isPunctuatorTokenWithValue(token, value) {
      return token.type === "Punctuator" && token.value === value;
    }
    function isArrowToken(token) {
      return isPunctuatorTokenWithValue(token, "=>");
    }
    function isCommaToken(token) {
      return isPunctuatorTokenWithValue(token, ",");
    }
    function isSemicolonToken(token) {
      return isPunctuatorTokenWithValue(token, ";");
    }
    function isColonToken(token) {
      return isPunctuatorTokenWithValue(token, ":");
    }
    function isOpeningParenToken(token) {
      return isPunctuatorTokenWithValue(token, "(");
    }
    function isClosingParenToken(token) {
      return isPunctuatorTokenWithValue(token, ")");
    }
    function isOpeningBracketToken(token) {
      return isPunctuatorTokenWithValue(token, "[");
    }
    function isClosingBracketToken(token) {
      return isPunctuatorTokenWithValue(token, "]");
    }
    function isOpeningBraceToken(token) {
      return isPunctuatorTokenWithValue(token, "{");
    }
    function isClosingBraceToken(token) {
      return isPunctuatorTokenWithValue(token, "}");
    }
    function isCommentToken(token) {
      return ["Block", "Line", "Shebang"].includes(token.type);
    }
    var isNotArrowToken = negate(isArrowToken);
    var isNotCommaToken = negate(isCommaToken);
    var isNotSemicolonToken = negate(isSemicolonToken);
    var isNotColonToken = negate(isColonToken);
    var isNotOpeningParenToken = negate(isOpeningParenToken);
    var isNotClosingParenToken = negate(isClosingParenToken);
    var isNotOpeningBracketToken = negate(isOpeningBracketToken);
    var isNotClosingBracketToken = negate(isClosingBracketToken);
    var isNotOpeningBraceToken = negate(isOpeningBraceToken);
    var isNotClosingBraceToken = negate(isClosingBraceToken);
    var isNotCommentToken = negate(isCommentToken);
    function getOpeningParenOfParams(node, sourceCode) {
      return node.id ? sourceCode.getTokenAfter(node.id, isOpeningParenToken) : sourceCode.getFirstToken(node, isOpeningParenToken);
    }
    function getFunctionHeadLocation(node, sourceCode) {
      const parent = node.parent;
      let start = null;
      let end = null;
      if (node.type === "ArrowFunctionExpression") {
        const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);
        start = arrowToken.loc.start;
        end = arrowToken.loc.end;
      } else if (parent.type === "Property" || parent.type === "MethodDefinition" || parent.type === "PropertyDefinition") {
        start = parent.loc.start;
        end = getOpeningParenOfParams(node, sourceCode).loc.start;
      } else {
        start = node.loc.start;
        end = getOpeningParenOfParams(node, sourceCode).loc.start;
      }
      return {
        start: { ...start },
        end: { ...end }
      };
    }
    var globalObject = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
    var builtinNames = Object.freeze(
      /* @__PURE__ */ new Set([
        "Array",
        "ArrayBuffer",
        "BigInt",
        "BigInt64Array",
        "BigUint64Array",
        "Boolean",
        "DataView",
        "Date",
        "decodeURI",
        "decodeURIComponent",
        "encodeURI",
        "encodeURIComponent",
        "escape",
        "Float32Array",
        "Float64Array",
        "Function",
        "Infinity",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "isFinite",
        "isNaN",
        "isPrototypeOf",
        "JSON",
        "Map",
        "Math",
        "NaN",
        "Number",
        "Object",
        "parseFloat",
        "parseInt",
        "Promise",
        "Proxy",
        "Reflect",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "undefined",
        "unescape",
        "WeakMap",
        "WeakSet"
      ])
    );
    var callAllowed = new Set(
      [
        Array.isArray,
        Array.of,
        Array.prototype.at,
        Array.prototype.concat,
        Array.prototype.entries,
        Array.prototype.every,
        Array.prototype.filter,
        Array.prototype.find,
        Array.prototype.findIndex,
        Array.prototype.flat,
        Array.prototype.includes,
        Array.prototype.indexOf,
        Array.prototype.join,
        Array.prototype.keys,
        Array.prototype.lastIndexOf,
        Array.prototype.slice,
        Array.prototype.some,
        Array.prototype.toString,
        Array.prototype.values,
        typeof BigInt === "function" ? BigInt : void 0,
        Boolean,
        Date,
        Date.parse,
        decodeURI,
        decodeURIComponent,
        encodeURI,
        encodeURIComponent,
        escape,
        isFinite,
        isNaN,
        isPrototypeOf,
        Map,
        Map.prototype.entries,
        Map.prototype.get,
        Map.prototype.has,
        Map.prototype.keys,
        Map.prototype.values,
        ...Object.getOwnPropertyNames(Math).filter((k) => k !== "random").map((k) => Math[k]).filter((f) => typeof f === "function"),
        Number,
        Number.isFinite,
        Number.isNaN,
        Number.parseFloat,
        Number.parseInt,
        Number.prototype.toExponential,
        Number.prototype.toFixed,
        Number.prototype.toPrecision,
        Number.prototype.toString,
        Object,
        Object.entries,
        Object.is,
        Object.isExtensible,
        Object.isFrozen,
        Object.isSealed,
        Object.keys,
        Object.values,
        parseFloat,
        parseInt,
        RegExp,
        Set,
        Set.prototype.entries,
        Set.prototype.has,
        Set.prototype.keys,
        Set.prototype.values,
        String,
        String.fromCharCode,
        String.fromCodePoint,
        String.raw,
        String.prototype.at,
        String.prototype.charAt,
        String.prototype.charCodeAt,
        String.prototype.codePointAt,
        String.prototype.concat,
        String.prototype.endsWith,
        String.prototype.includes,
        String.prototype.indexOf,
        String.prototype.lastIndexOf,
        String.prototype.normalize,
        String.prototype.padEnd,
        String.prototype.padStart,
        String.prototype.slice,
        String.prototype.startsWith,
        String.prototype.substr,
        String.prototype.substring,
        String.prototype.toLowerCase,
        String.prototype.toString,
        String.prototype.toUpperCase,
        String.prototype.trim,
        String.prototype.trimEnd,
        String.prototype.trimLeft,
        String.prototype.trimRight,
        String.prototype.trimStart,
        Symbol.for,
        Symbol.keyFor,
        unescape
      ].filter((f) => typeof f === "function")
    );
    var callPassThrough = /* @__PURE__ */ new Set([
      Object.freeze,
      Object.preventExtensions,
      Object.seal
    ]);
    var getterAllowed = [
      [Map, /* @__PURE__ */ new Set(["size"])],
      [
        RegExp,
        /* @__PURE__ */ new Set([
          "dotAll",
          "flags",
          "global",
          "hasIndices",
          "ignoreCase",
          "multiline",
          "source",
          "sticky",
          "unicode"
        ])
      ],
      [Set, /* @__PURE__ */ new Set(["size"])]
    ];
    function getPropertyDescriptor(object, name) {
      let x = object;
      while ((typeof x === "object" || typeof x === "function") && x !== null) {
        const d = Object.getOwnPropertyDescriptor(x, name);
        if (d) {
          return d;
        }
        x = Object.getPrototypeOf(x);
      }
      return null;
    }
    function isGetter(object, name) {
      const d = getPropertyDescriptor(object, name);
      return d != null && d.get != null;
    }
    function getElementValues(nodeList, initialScope) {
      const valueList = [];
      for (let i = 0; i < nodeList.length; ++i) {
        const elementNode = nodeList[i];
        if (elementNode == null) {
          valueList.length = i + 1;
        } else if (elementNode.type === "SpreadElement") {
          const argument = getStaticValueR(elementNode.argument, initialScope);
          if (argument == null) {
            return null;
          }
          valueList.push(...argument.value);
        } else {
          const element = getStaticValueR(elementNode, initialScope);
          if (element == null) {
            return null;
          }
          valueList.push(element.value);
        }
      }
      return valueList;
    }
    function isEffectivelyConst(variable) {
      const refs = variable.references;
      const inits = refs.filter((r) => r.init).length;
      const reads = refs.filter((r) => r.isReadOnly()).length;
      if (inits === 1 && reads + inits === refs.length) {
        return true;
      }
      return false;
    }
    var operations = Object.freeze({
      ArrayExpression(node, initialScope) {
        const elements = getElementValues(node.elements, initialScope);
        return elements != null ? { value: elements } : null;
      },
      AssignmentExpression(node, initialScope) {
        if (node.operator === "=") {
          return getStaticValueR(node.right, initialScope);
        }
        return null;
      },
      //eslint-disable-next-line complexity
      BinaryExpression(node, initialScope) {
        if (node.operator === "in" || node.operator === "instanceof") {
          return null;
        }
        const left = getStaticValueR(node.left, initialScope);
        const right = getStaticValueR(node.right, initialScope);
        if (left != null && right != null) {
          switch (node.operator) {
            case "==":
              return { value: left.value == right.value };
            case "!=":
              return { value: left.value != right.value };
            case "===":
              return { value: left.value === right.value };
            case "!==":
              return { value: left.value !== right.value };
            case "<":
              return { value: left.value < right.value };
            case "<=":
              return { value: left.value <= right.value };
            case ">":
              return { value: left.value > right.value };
            case ">=":
              return { value: left.value >= right.value };
            case "<<":
              return { value: left.value << right.value };
            case ">>":
              return { value: left.value >> right.value };
            case ">>>":
              return { value: left.value >>> right.value };
            case "+":
              return { value: left.value + right.value };
            case "-":
              return { value: left.value - right.value };
            case "*":
              return { value: left.value * right.value };
            case "/":
              return { value: left.value / right.value };
            case "%":
              return { value: left.value % right.value };
            case "**":
              return { value: left.value ** right.value };
            case "|":
              return { value: left.value | right.value };
            case "^":
              return { value: left.value ^ right.value };
            case "&":
              return { value: left.value & right.value };
          }
        }
        return null;
      },
      CallExpression(node, initialScope) {
        const calleeNode = node.callee;
        const args = getElementValues(node.arguments, initialScope);
        if (args != null) {
          if (calleeNode.type === "MemberExpression") {
            if (calleeNode.property.type === "PrivateIdentifier") {
              return null;
            }
            const object = getStaticValueR(calleeNode.object, initialScope);
            if (object != null) {
              if (object.value == null && (object.optional || node.optional)) {
                return { value: void 0, optional: true };
              }
              const property = getStaticPropertyNameValue(
                calleeNode,
                initialScope
              );
              if (property != null) {
                const receiver = object.value;
                const methodName = property.value;
                if (callAllowed.has(receiver[methodName])) {
                  return { value: receiver[methodName](...args) };
                }
                if (callPassThrough.has(receiver[methodName])) {
                  return { value: args[0] };
                }
              }
            }
          } else {
            const callee = getStaticValueR(calleeNode, initialScope);
            if (callee != null) {
              if (callee.value == null && node.optional) {
                return { value: void 0, optional: true };
              }
              const func = callee.value;
              if (callAllowed.has(func)) {
                return { value: func(...args) };
              }
              if (callPassThrough.has(func)) {
                return { value: args[0] };
              }
            }
          }
        }
        return null;
      },
      ConditionalExpression(node, initialScope) {
        const test = getStaticValueR(node.test, initialScope);
        if (test != null) {
          return test.value ? getStaticValueR(node.consequent, initialScope) : getStaticValueR(node.alternate, initialScope);
        }
        return null;
      },
      ExpressionStatement(node, initialScope) {
        return getStaticValueR(node.expression, initialScope);
      },
      Identifier(node, initialScope) {
        if (initialScope != null) {
          const variable = findVariable(initialScope, node);
          if (variable != null && variable.defs.length === 0 && builtinNames.has(variable.name) && variable.name in globalObject) {
            return { value: globalObject[variable.name] };
          }
          if (variable != null && variable.defs.length === 1) {
            const def = variable.defs[0];
            if (def.parent && def.type === "Variable" && (def.parent.kind === "const" || isEffectivelyConst(variable)) && // TODO(mysticatea): don't support destructuring here.
            def.node.id.type === "Identifier") {
              return getStaticValueR(def.node.init, initialScope);
            }
          }
        }
        return null;
      },
      Literal(node) {
        if ((node.regex != null || node.bigint != null) && node.value == null) {
          return null;
        }
        return { value: node.value };
      },
      LogicalExpression(node, initialScope) {
        const left = getStaticValueR(node.left, initialScope);
        if (left != null) {
          if (node.operator === "||" && Boolean(left.value) === true || node.operator === "&&" && Boolean(left.value) === false || node.operator === "??" && left.value != null) {
            return left;
          }
          const right = getStaticValueR(node.right, initialScope);
          if (right != null) {
            return right;
          }
        }
        return null;
      },
      MemberExpression(node, initialScope) {
        if (node.property.type === "PrivateIdentifier") {
          return null;
        }
        const object = getStaticValueR(node.object, initialScope);
        if (object != null) {
          if (object.value == null && (object.optional || node.optional)) {
            return { value: void 0, optional: true };
          }
          const property = getStaticPropertyNameValue(node, initialScope);
          if (property != null) {
            if (!isGetter(object.value, property.value)) {
              return { value: object.value[property.value] };
            }
            for (const [classFn, allowed] of getterAllowed) {
              if (object.value instanceof classFn && allowed.has(property.value)) {
                return { value: object.value[property.value] };
              }
            }
          }
        }
        return null;
      },
      ChainExpression(node, initialScope) {
        const expression = getStaticValueR(node.expression, initialScope);
        if (expression != null) {
          return { value: expression.value };
        }
        return null;
      },
      NewExpression(node, initialScope) {
        const callee = getStaticValueR(node.callee, initialScope);
        const args = getElementValues(node.arguments, initialScope);
        if (callee != null && args != null) {
          const Func = callee.value;
          if (callAllowed.has(Func)) {
            return { value: new Func(...args) };
          }
        }
        return null;
      },
      ObjectExpression(node, initialScope) {
        const object = {};
        for (const propertyNode of node.properties) {
          if (propertyNode.type === "Property") {
            if (propertyNode.kind !== "init") {
              return null;
            }
            const key = getStaticPropertyNameValue(
              propertyNode,
              initialScope
            );
            const value = getStaticValueR(propertyNode.value, initialScope);
            if (key == null || value == null) {
              return null;
            }
            object[key.value] = value.value;
          } else if (propertyNode.type === "SpreadElement" || propertyNode.type === "ExperimentalSpreadProperty") {
            const argument = getStaticValueR(
              propertyNode.argument,
              initialScope
            );
            if (argument == null) {
              return null;
            }
            Object.assign(object, argument.value);
          } else {
            return null;
          }
        }
        return { value: object };
      },
      SequenceExpression(node, initialScope) {
        const last = node.expressions[node.expressions.length - 1];
        return getStaticValueR(last, initialScope);
      },
      TaggedTemplateExpression(node, initialScope) {
        const tag = getStaticValueR(node.tag, initialScope);
        const expressions = getElementValues(
          node.quasi.expressions,
          initialScope
        );
        if (tag != null && expressions != null) {
          const func = tag.value;
          const strings = node.quasi.quasis.map((q) => q.value.cooked);
          strings.raw = node.quasi.quasis.map((q) => q.value.raw);
          if (func === String.raw) {
            return { value: func(strings, ...expressions) };
          }
        }
        return null;
      },
      TemplateLiteral(node, initialScope) {
        const expressions = getElementValues(node.expressions, initialScope);
        if (expressions != null) {
          let value = node.quasis[0].value.cooked;
          for (let i = 0; i < expressions.length; ++i) {
            value += expressions[i];
            value += node.quasis[i + 1].value.cooked;
          }
          return { value };
        }
        return null;
      },
      UnaryExpression(node, initialScope) {
        if (node.operator === "delete") {
          return null;
        }
        if (node.operator === "void") {
          return { value: void 0 };
        }
        const arg = getStaticValueR(node.argument, initialScope);
        if (arg != null) {
          switch (node.operator) {
            case "-":
              return { value: -arg.value };
            case "+":
              return { value: +arg.value };
            case "!":
              return { value: !arg.value };
            case "~":
              return { value: ~arg.value };
            case "typeof":
              return { value: typeof arg.value };
          }
        }
        return null;
      }
    });
    function getStaticValueR(node, initialScope) {
      if (node != null && Object.hasOwnProperty.call(operations, node.type)) {
        return operations[node.type](node, initialScope);
      }
      return null;
    }
    function getStaticPropertyNameValue(node, initialScope) {
      const nameNode = node.type === "Property" ? node.key : node.property;
      if (node.computed) {
        return getStaticValueR(nameNode, initialScope);
      }
      if (nameNode.type === "Identifier") {
        return { value: nameNode.name };
      }
      if (nameNode.type === "Literal") {
        if (nameNode.bigint) {
          return { value: nameNode.bigint };
        }
        return { value: String(nameNode.value) };
      }
      return null;
    }
    function getStaticValue(node, initialScope = null) {
      try {
        return getStaticValueR(node, initialScope);
      } catch (_error) {
        return null;
      }
    }
    function getStringIfConstant(node, initialScope = null) {
      if (node && node.type === "Literal" && node.value === null) {
        if (node.regex) {
          return `/${node.regex.pattern}/${node.regex.flags}`;
        }
        if (node.bigint) {
          return node.bigint;
        }
      }
      const evaluated = getStaticValue(node, initialScope);
      return evaluated && String(evaluated.value);
    }
    function getPropertyName(node, initialScope) {
      switch (node.type) {
        case "MemberExpression":
          if (node.computed) {
            return getStringIfConstant(node.property, initialScope);
          }
          if (node.property.type === "PrivateIdentifier") {
            return null;
          }
          return node.property.name;
        case "Property":
        case "MethodDefinition":
        case "PropertyDefinition":
          if (node.computed) {
            return getStringIfConstant(node.key, initialScope);
          }
          if (node.key.type === "Literal") {
            return String(node.key.value);
          }
          if (node.key.type === "PrivateIdentifier") {
            return null;
          }
          return node.key.name;
      }
      return null;
    }
    function getFunctionNameWithKind(node, sourceCode) {
      const parent = node.parent;
      const tokens = [];
      const isObjectMethod = parent.type === "Property" && parent.value === node;
      const isClassMethod = parent.type === "MethodDefinition" && parent.value === node;
      const isClassFieldMethod = parent.type === "PropertyDefinition" && parent.value === node;
      if (isClassMethod || isClassFieldMethod) {
        if (parent.static) {
          tokens.push("static");
        }
        if (parent.key.type === "PrivateIdentifier") {
          tokens.push("private");
        }
      }
      if (node.async) {
        tokens.push("async");
      }
      if (node.generator) {
        tokens.push("generator");
      }
      if (isObjectMethod || isClassMethod) {
        if (parent.kind === "constructor") {
          return "constructor";
        }
        if (parent.kind === "get") {
          tokens.push("getter");
        } else if (parent.kind === "set") {
          tokens.push("setter");
        } else {
          tokens.push("method");
        }
      } else if (isClassFieldMethod) {
        tokens.push("method");
      } else {
        if (node.type === "ArrowFunctionExpression") {
          tokens.push("arrow");
        }
        tokens.push("function");
      }
      if (isObjectMethod || isClassMethod || isClassFieldMethod) {
        if (parent.key.type === "PrivateIdentifier") {
          tokens.push(`#${parent.key.name}`);
        } else {
          const name = getPropertyName(parent);
          if (name) {
            tokens.push(`'${name}'`);
          } else if (sourceCode) {
            const keyText = sourceCode.getText(parent.key);
            if (!keyText.includes("\n")) {
              tokens.push(`[${keyText}]`);
            }
          }
        }
      } else if (node.id) {
        tokens.push(`'${node.id.name}'`);
      } else if (parent.type === "VariableDeclarator" && parent.id && parent.id.type === "Identifier") {
        tokens.push(`'${parent.id.name}'`);
      } else if ((parent.type === "AssignmentExpression" || parent.type === "AssignmentPattern") && parent.left && parent.left.type === "Identifier") {
        tokens.push(`'${parent.left.name}'`);
      } else if (parent.type === "ExportDefaultDeclaration" && parent.declaration === node) {
        tokens.push("'default'");
      }
      return tokens.join(" ");
    }
    var typeConversionBinaryOps = Object.freeze(
      /* @__PURE__ */ new Set([
        "==",
        "!=",
        "<",
        "<=",
        ">",
        ">=",
        "<<",
        ">>",
        ">>>",
        "+",
        "-",
        "*",
        "/",
        "%",
        "|",
        "^",
        "&",
        "in"
      ])
    );
    var typeConversionUnaryOps = Object.freeze(/* @__PURE__ */ new Set(["-", "+", "!", "~"]));
    function isNode(x) {
      return x !== null && typeof x === "object" && typeof x.type === "string";
    }
    var visitor = Object.freeze(
      Object.assign(/* @__PURE__ */ Object.create(null), {
        $visit(node, options, visitorKeys) {
          const { type } = node;
          if (typeof this[type] === "function") {
            return this[type](node, options, visitorKeys);
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        $visitChildren(node, options, visitorKeys) {
          const { type } = node;
          for (const key of visitorKeys[type] || eslintVisitorKeys.getKeys(node)) {
            const value = node[key];
            if (Array.isArray(value)) {
              for (const element of value) {
                if (isNode(element) && this.$visit(element, options, visitorKeys)) {
                  return true;
                }
              }
            } else if (isNode(value) && this.$visit(value, options, visitorKeys)) {
              return true;
            }
          }
          return false;
        },
        ArrowFunctionExpression() {
          return false;
        },
        AssignmentExpression() {
          return true;
        },
        AwaitExpression() {
          return true;
        },
        BinaryExpression(node, options, visitorKeys) {
          if (options.considerImplicitTypeConversion && typeConversionBinaryOps.has(node.operator) && (node.left.type !== "Literal" || node.right.type !== "Literal")) {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        CallExpression() {
          return true;
        },
        FunctionExpression() {
          return false;
        },
        ImportExpression() {
          return true;
        },
        MemberExpression(node, options, visitorKeys) {
          if (options.considerGetters) {
            return true;
          }
          if (options.considerImplicitTypeConversion && node.computed && node.property.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        MethodDefinition(node, options, visitorKeys) {
          if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        NewExpression() {
          return true;
        },
        Property(node, options, visitorKeys) {
          if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        PropertyDefinition(node, options, visitorKeys) {
          if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        UnaryExpression(node, options, visitorKeys) {
          if (node.operator === "delete") {
            return true;
          }
          if (options.considerImplicitTypeConversion && typeConversionUnaryOps.has(node.operator) && node.argument.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        UpdateExpression() {
          return true;
        },
        YieldExpression() {
          return true;
        }
      })
    );
    function hasSideEffect(node, sourceCode, { considerGetters = false, considerImplicitTypeConversion = false } = {}) {
      return visitor.$visit(
        node,
        { considerGetters, considerImplicitTypeConversion },
        sourceCode.visitorKeys || eslintVisitorKeys.KEYS
      );
    }
    function getParentSyntaxParen(node, sourceCode) {
      const parent = node.parent;
      switch (parent.type) {
        case "CallExpression":
        case "NewExpression":
          if (parent.arguments.length === 1 && parent.arguments[0] === node) {
            return sourceCode.getTokenAfter(
              parent.callee,
              isOpeningParenToken
            );
          }
          return null;
        case "DoWhileStatement":
          if (parent.test === node) {
            return sourceCode.getTokenAfter(
              parent.body,
              isOpeningParenToken
            );
          }
          return null;
        case "IfStatement":
        case "WhileStatement":
          if (parent.test === node) {
            return sourceCode.getFirstToken(parent, 1);
          }
          return null;
        case "ImportExpression":
          if (parent.source === node) {
            return sourceCode.getFirstToken(parent, 1);
          }
          return null;
        case "SwitchStatement":
          if (parent.discriminant === node) {
            return sourceCode.getFirstToken(parent, 1);
          }
          return null;
        case "WithStatement":
          if (parent.object === node) {
            return sourceCode.getFirstToken(parent, 1);
          }
          return null;
        default:
          return null;
      }
    }
    function isParenthesized(timesOrNode, nodeOrSourceCode, optionalSourceCode) {
      let times, node, sourceCode, maybeLeftParen, maybeRightParen;
      if (typeof timesOrNode === "number") {
        times = timesOrNode | 0;
        node = nodeOrSourceCode;
        sourceCode = optionalSourceCode;
        if (!(times >= 1)) {
          throw new TypeError("'times' should be a positive integer.");
        }
      } else {
        times = 1;
        node = timesOrNode;
        sourceCode = nodeOrSourceCode;
      }
      if (node == null || // `Program` can't be parenthesized
      node.parent == null || // `CatchClause.param` can't be parenthesized, example `try {} catch (error) {}`
      node.parent.type === "CatchClause" && node.parent.param === node) {
        return false;
      }
      maybeLeftParen = maybeRightParen = node;
      do {
        maybeLeftParen = sourceCode.getTokenBefore(maybeLeftParen);
        maybeRightParen = sourceCode.getTokenAfter(maybeRightParen);
      } while (maybeLeftParen != null && maybeRightParen != null && isOpeningParenToken(maybeLeftParen) && isClosingParenToken(maybeRightParen) && // Avoid false positive such as `if (a) {}`
      maybeLeftParen !== getParentSyntaxParen(node, sourceCode) && --times > 0);
      return times === 0;
    }
    var placeholder = /\$(?:[$&`']|[1-9][0-9]?)/gu;
    var internal = /* @__PURE__ */ new WeakMap();
    function isEscaped(str, index2) {
      let escaped = false;
      for (let i = index2 - 1; i >= 0 && str.charCodeAt(i) === 92; --i) {
        escaped = !escaped;
      }
      return escaped;
    }
    function replaceS(matcher, str, replacement) {
      const chunks = [];
      let index2 = 0;
      let match = null;
      function replacer(key) {
        switch (key) {
          case "$$":
            return "$";
          case "$&":
            return match[0];
          case "$`":
            return str.slice(0, match.index);
          case "$'":
            return str.slice(match.index + match[0].length);
          default: {
            const i = key.slice(1);
            if (i in match) {
              return match[i];
            }
            return key;
          }
        }
      }
      for (match of matcher.execAll(str)) {
        chunks.push(str.slice(index2, match.index));
        chunks.push(replacement.replace(placeholder, replacer));
        index2 = match.index + match[0].length;
      }
      chunks.push(str.slice(index2));
      return chunks.join("");
    }
    function replaceF(matcher, str, replace) {
      const chunks = [];
      let index2 = 0;
      for (const match of matcher.execAll(str)) {
        chunks.push(str.slice(index2, match.index));
        chunks.push(String(replace(...match, match.index, match.input)));
        index2 = match.index + match[0].length;
      }
      chunks.push(str.slice(index2));
      return chunks.join("");
    }
    var PatternMatcher = class {
      /**
       * Initialize this matcher.
       * @param {RegExp} pattern The pattern to match.
       * @param {{escaped:boolean}} options The options.
       */
      constructor(pattern, { escaped = false } = {}) {
        if (!(pattern instanceof RegExp)) {
          throw new TypeError("'pattern' should be a RegExp instance.");
        }
        if (!pattern.flags.includes("g")) {
          throw new Error("'pattern' should contains 'g' flag.");
        }
        internal.set(this, {
          pattern: new RegExp(pattern.source, pattern.flags),
          escaped: Boolean(escaped)
        });
      }
      /**
       * Find the pattern in a given string.
       * @param {string} str The string to find.
       * @returns {IterableIterator<RegExpExecArray>} The iterator which iterate the matched information.
       */
      *execAll(str) {
        const { pattern, escaped } = internal.get(this);
        let match = null;
        let lastIndex = 0;
        pattern.lastIndex = 0;
        while ((match = pattern.exec(str)) != null) {
          if (escaped || !isEscaped(str, match.index)) {
            lastIndex = pattern.lastIndex;
            yield match;
            pattern.lastIndex = lastIndex;
          }
        }
      }
      /**
       * Check whether the pattern is found in a given string.
       * @param {string} str The string to check.
       * @returns {boolean} `true` if the pattern was found in the string.
       */
      test(str) {
        const it = this.execAll(str);
        const ret = it.next();
        return !ret.done;
      }
      /**
       * Replace a given string.
       * @param {string} str The string to be replaced.
       * @param {(string|((...strs:string[])=>string))} replacer The string or function to replace. This is the same as the 2nd argument of `String.prototype.replace`.
       * @returns {string} The replaced string.
       */
      [Symbol.replace](str, replacer) {
        return typeof replacer === "function" ? replaceF(this, String(str), replacer) : replaceS(this, String(str), String(replacer));
      }
    };
    var IMPORT_TYPE = /^(?:Import|Export(?:All|Default|Named))Declaration$/u;
    var has = Function.call.bind(Object.hasOwnProperty);
    var READ = Symbol("read");
    var CALL = Symbol("call");
    var CONSTRUCT = Symbol("construct");
    var ESM = Symbol("esm");
    var requireCall = { require: { [CALL]: true } };
    function isModifiedGlobal(variable) {
      return variable == null || variable.defs.length !== 0 || variable.references.some((r) => r.isWrite());
    }
    function isPassThrough(node) {
      const parent = node.parent;
      switch (parent && parent.type) {
        case "ConditionalExpression":
          return parent.consequent === node || parent.alternate === node;
        case "LogicalExpression":
          return true;
        case "SequenceExpression":
          return parent.expressions[parent.expressions.length - 1] === node;
        case "ChainExpression":
          return true;
        default:
          return false;
      }
    }
    var ReferenceTracker = class {
      /**
       * Initialize this tracker.
       * @param {Scope} globalScope The global scope.
       * @param {object} [options] The options.
       * @param {"legacy"|"strict"} [options.mode="strict"] The mode to determine the ImportDeclaration's behavior for CJS modules.
       * @param {string[]} [options.globalObjectNames=["global","globalThis","self","window"]] The variable names for Global Object.
       */
      constructor(globalScope, {
        mode = "strict",
        globalObjectNames = ["global", "globalThis", "self", "window"]
      } = {}) {
        this.variableStack = [];
        this.globalScope = globalScope;
        this.mode = mode;
        this.globalObjectNames = globalObjectNames.slice(0);
      }
      /**
       * Iterate the references of global variables.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *iterateGlobalReferences(traceMap) {
        for (const key of Object.keys(traceMap)) {
          const nextTraceMap = traceMap[key];
          const path = [key];
          const variable = this.globalScope.set.get(key);
          if (isModifiedGlobal(variable)) {
            continue;
          }
          yield* this._iterateVariableReferences(
            variable,
            path,
            nextTraceMap,
            true
          );
        }
        for (const key of this.globalObjectNames) {
          const path = [];
          const variable = this.globalScope.set.get(key);
          if (isModifiedGlobal(variable)) {
            continue;
          }
          yield* this._iterateVariableReferences(
            variable,
            path,
            traceMap,
            false
          );
        }
      }
      /**
       * Iterate the references of CommonJS modules.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *iterateCjsReferences(traceMap) {
        for (const { node } of this.iterateGlobalReferences(requireCall)) {
          const key = getStringIfConstant(node.arguments[0]);
          if (key == null || !has(traceMap, key)) {
            continue;
          }
          const nextTraceMap = traceMap[key];
          const path = [key];
          if (nextTraceMap[READ]) {
            yield {
              node,
              path,
              type: READ,
              info: nextTraceMap[READ]
            };
          }
          yield* this._iteratePropertyReferences(node, path, nextTraceMap);
        }
      }
      /**
       * Iterate the references of ES modules.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *iterateEsmReferences(traceMap) {
        const programNode = this.globalScope.block;
        for (const node of programNode.body) {
          if (!IMPORT_TYPE.test(node.type) || node.source == null) {
            continue;
          }
          const moduleId = node.source.value;
          if (!has(traceMap, moduleId)) {
            continue;
          }
          const nextTraceMap = traceMap[moduleId];
          const path = [moduleId];
          if (nextTraceMap[READ]) {
            yield { node, path, type: READ, info: nextTraceMap[READ] };
          }
          if (node.type === "ExportAllDeclaration") {
            for (const key of Object.keys(nextTraceMap)) {
              const exportTraceMap = nextTraceMap[key];
              if (exportTraceMap[READ]) {
                yield {
                  node,
                  path: path.concat(key),
                  type: READ,
                  info: exportTraceMap[READ]
                };
              }
            }
          } else {
            for (const specifier of node.specifiers) {
              const esm = has(nextTraceMap, ESM);
              const it = this._iterateImportReferences(
                specifier,
                path,
                esm ? nextTraceMap : this.mode === "legacy" ? { default: nextTraceMap, ...nextTraceMap } : { default: nextTraceMap }
              );
              if (esm) {
                yield* it;
              } else {
                for (const report of it) {
                  report.path = report.path.filter(exceptDefault);
                  if (report.path.length >= 2 || report.type !== READ) {
                    yield report;
                  }
                }
              }
            }
          }
        }
      }
      /**
       * Iterate the references for a given variable.
       * @param {Variable} variable The variable to iterate that references.
       * @param {string[]} path The current path.
       * @param {object} traceMap The trace map.
       * @param {boolean} shouldReport = The flag to report those references.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *_iterateVariableReferences(variable, path, traceMap, shouldReport) {
        if (this.variableStack.includes(variable)) {
          return;
        }
        this.variableStack.push(variable);
        try {
          for (const reference of variable.references) {
            if (!reference.isRead()) {
              continue;
            }
            const node = reference.identifier;
            if (shouldReport && traceMap[READ]) {
              yield { node, path, type: READ, info: traceMap[READ] };
            }
            yield* this._iteratePropertyReferences(node, path, traceMap);
          }
        } finally {
          this.variableStack.pop();
        }
      }
      /**
       * Iterate the references for a given AST node.
       * @param rootNode The AST node to iterate references.
       * @param {string[]} path The current path.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      //eslint-disable-next-line complexity
      *_iteratePropertyReferences(rootNode, path, traceMap) {
        let node = rootNode;
        while (isPassThrough(node)) {
          node = node.parent;
        }
        const parent = node.parent;
        if (parent.type === "MemberExpression") {
          if (parent.object === node) {
            const key = getPropertyName(parent);
            if (key == null || !has(traceMap, key)) {
              return;
            }
            path = path.concat(key);
            const nextTraceMap = traceMap[key];
            if (nextTraceMap[READ]) {
              yield {
                node: parent,
                path,
                type: READ,
                info: nextTraceMap[READ]
              };
            }
            yield* this._iteratePropertyReferences(
              parent,
              path,
              nextTraceMap
            );
          }
          return;
        }
        if (parent.type === "CallExpression") {
          if (parent.callee === node && traceMap[CALL]) {
            yield { node: parent, path, type: CALL, info: traceMap[CALL] };
          }
          return;
        }
        if (parent.type === "NewExpression") {
          if (parent.callee === node && traceMap[CONSTRUCT]) {
            yield {
              node: parent,
              path,
              type: CONSTRUCT,
              info: traceMap[CONSTRUCT]
            };
          }
          return;
        }
        if (parent.type === "AssignmentExpression") {
          if (parent.right === node) {
            yield* this._iterateLhsReferences(parent.left, path, traceMap);
            yield* this._iteratePropertyReferences(parent, path, traceMap);
          }
          return;
        }
        if (parent.type === "AssignmentPattern") {
          if (parent.right === node) {
            yield* this._iterateLhsReferences(parent.left, path, traceMap);
          }
          return;
        }
        if (parent.type === "VariableDeclarator") {
          if (parent.init === node) {
            yield* this._iterateLhsReferences(parent.id, path, traceMap);
          }
        }
      }
      /**
       * Iterate the references for a given Pattern node.
       * @param {Node} patternNode The Pattern node to iterate references.
       * @param {string[]} path The current path.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *_iterateLhsReferences(patternNode, path, traceMap) {
        if (patternNode.type === "Identifier") {
          const variable = findVariable(this.globalScope, patternNode);
          if (variable != null) {
            yield* this._iterateVariableReferences(
              variable,
              path,
              traceMap,
              false
            );
          }
          return;
        }
        if (patternNode.type === "ObjectPattern") {
          for (const property of patternNode.properties) {
            const key = getPropertyName(property);
            if (key == null || !has(traceMap, key)) {
              continue;
            }
            const nextPath = path.concat(key);
            const nextTraceMap = traceMap[key];
            if (nextTraceMap[READ]) {
              yield {
                node: property,
                path: nextPath,
                type: READ,
                info: nextTraceMap[READ]
              };
            }
            yield* this._iterateLhsReferences(
              property.value,
              nextPath,
              nextTraceMap
            );
          }
          return;
        }
        if (patternNode.type === "AssignmentPattern") {
          yield* this._iterateLhsReferences(patternNode.left, path, traceMap);
        }
      }
      /**
       * Iterate the references for a given ModuleSpecifier node.
       * @param {Node} specifierNode The ModuleSpecifier node to iterate references.
       * @param {string[]} path The current path.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *_iterateImportReferences(specifierNode, path, traceMap) {
        const type = specifierNode.type;
        if (type === "ImportSpecifier" || type === "ImportDefaultSpecifier") {
          const key = type === "ImportDefaultSpecifier" ? "default" : specifierNode.imported.name;
          if (!has(traceMap, key)) {
            return;
          }
          path = path.concat(key);
          const nextTraceMap = traceMap[key];
          if (nextTraceMap[READ]) {
            yield {
              node: specifierNode,
              path,
              type: READ,
              info: nextTraceMap[READ]
            };
          }
          yield* this._iterateVariableReferences(
            findVariable(this.globalScope, specifierNode.local),
            path,
            nextTraceMap,
            false
          );
          return;
        }
        if (type === "ImportNamespaceSpecifier") {
          yield* this._iterateVariableReferences(
            findVariable(this.globalScope, specifierNode.local),
            path,
            traceMap,
            false
          );
          return;
        }
        if (type === "ExportSpecifier") {
          const key = specifierNode.local.name;
          if (!has(traceMap, key)) {
            return;
          }
          path = path.concat(key);
          const nextTraceMap = traceMap[key];
          if (nextTraceMap[READ]) {
            yield {
              node: specifierNode,
              path,
              type: READ,
              info: nextTraceMap[READ]
            };
          }
        }
      }
    };
    ReferenceTracker.READ = READ;
    ReferenceTracker.CALL = CALL;
    ReferenceTracker.CONSTRUCT = CONSTRUCT;
    ReferenceTracker.ESM = ESM;
    function exceptDefault(name, index2) {
      return !(index2 === 1 && name === "default");
    }
    var index = {
      CALL,
      CONSTRUCT,
      ESM,
      findVariable,
      getFunctionHeadLocation,
      getFunctionNameWithKind,
      getInnermostScope,
      getPropertyName,
      getStaticValue,
      getStringIfConstant,
      hasSideEffect,
      isArrowToken,
      isClosingBraceToken,
      isClosingBracketToken,
      isClosingParenToken,
      isColonToken,
      isCommaToken,
      isCommentToken,
      isNotArrowToken,
      isNotClosingBraceToken,
      isNotClosingBracketToken,
      isNotClosingParenToken,
      isNotColonToken,
      isNotCommaToken,
      isNotCommentToken,
      isNotOpeningBraceToken,
      isNotOpeningBracketToken,
      isNotOpeningParenToken,
      isNotSemicolonToken,
      isOpeningBraceToken,
      isOpeningBracketToken,
      isOpeningParenToken,
      isParenthesized,
      isSemicolonToken,
      PatternMatcher,
      READ,
      ReferenceTracker
    };
    exports.CALL = CALL;
    exports.CONSTRUCT = CONSTRUCT;
    exports.ESM = ESM;
    exports.PatternMatcher = PatternMatcher;
    exports.READ = READ;
    exports.ReferenceTracker = ReferenceTracker;
    exports["default"] = index;
    exports.findVariable = findVariable;
    exports.getFunctionHeadLocation = getFunctionHeadLocation;
    exports.getFunctionNameWithKind = getFunctionNameWithKind;
    exports.getInnermostScope = getInnermostScope;
    exports.getPropertyName = getPropertyName;
    exports.getStaticValue = getStaticValue;
    exports.getStringIfConstant = getStringIfConstant;
    exports.hasSideEffect = hasSideEffect;
    exports.isArrowToken = isArrowToken;
    exports.isClosingBraceToken = isClosingBraceToken;
    exports.isClosingBracketToken = isClosingBracketToken;
    exports.isClosingParenToken = isClosingParenToken;
    exports.isColonToken = isColonToken;
    exports.isCommaToken = isCommaToken;
    exports.isCommentToken = isCommentToken;
    exports.isNotArrowToken = isNotArrowToken;
    exports.isNotClosingBraceToken = isNotClosingBraceToken;
    exports.isNotClosingBracketToken = isNotClosingBracketToken;
    exports.isNotClosingParenToken = isNotClosingParenToken;
    exports.isNotColonToken = isNotColonToken;
    exports.isNotCommaToken = isNotCommaToken;
    exports.isNotCommentToken = isNotCommentToken;
    exports.isNotOpeningBraceToken = isNotOpeningBraceToken;
    exports.isNotOpeningBracketToken = isNotOpeningBracketToken;
    exports.isNotOpeningParenToken = isNotOpeningParenToken;
    exports.isNotSemicolonToken = isNotSemicolonToken;
    exports.isOpeningBraceToken = isOpeningBraceToken;
    exports.isOpeningBracketToken = isOpeningBracketToken;
    exports.isOpeningParenToken = isOpeningParenToken;
    exports.isParenthesized = isParenthesized;
    exports.isSemicolonToken = isSemicolonToken;
  }
});

// node_modules/eslint-plugin-vue/lib/utils/ts-utils/typescript.js
var require_typescript = __commonJS({
  "node_modules/eslint-plugin-vue/lib/utils/ts-utils/typescript.js"(exports, module) {
    var cacheTypeScript;
    module.exports = {
      getTypeScript,
      isObject,
      isAny,
      isUnknown,
      isNever,
      isNull,
      isFunction,
      isArrayLikeObject,
      isStringLike,
      isNumberLike,
      isBooleanLike,
      isBigIntLike,
      isReferenceObject,
      extractTypeFlags,
      extractObjectFlags
    };
    function getTypeScript() {
      if (cacheTypeScript) {
        return cacheTypeScript;
      }
      try {
        return cacheTypeScript = __require("typescript");
      } catch (error) {
        if (
          /** @type {any} */
          error.code === "MODULE_NOT_FOUND"
        ) {
          return void 0;
        }
        throw error;
      }
    }
    function extractTypeFlags(tsType) {
      const ts = (
        /** @type {TypeScript} */
        getTypeScript()
      );
      const result = [];
      const keys = (
        /** @type {(keyof (typeof ts.TypeFlags))[]} */
        Object.keys(ts.TypeFlags)
      );
      for (const k of keys) {
        if ((tsType.flags & ts.TypeFlags[k]) !== 0) {
          result.push(k);
        }
      }
      return result;
    }
    function extractObjectFlags(tsType) {
      if (!isObject(tsType)) {
        return [];
      }
      const ts = (
        /** @type {TypeScript} */
        getTypeScript()
      );
      const result = [];
      const keys = (
        /** @type {(keyof (typeof ts.ObjectFlags))[]} */
        Object.keys(ts.ObjectFlags)
      );
      for (const k of keys) {
        if ((tsType.objectFlags & ts.ObjectFlags[k]) !== 0) {
          result.push(k);
        }
      }
      return result;
    }
    function isObject(tsType) {
      const ts = (
        /** @type {TypeScript} */
        getTypeScript()
      );
      return (tsType.flags & ts.TypeFlags.Object) !== 0;
    }
    function isArrayLikeObject(tsType) {
      const ts = (
        /** @type {TypeScript} */
        getTypeScript()
      );
      return isObject(tsType) && (tsType.objectFlags & (ts.ObjectFlags.ArrayLiteral | ts.ObjectFlags.EvolvingArray | ts.ObjectFlags.Tuple)) !== 0;
    }
    function isAny(tsType) {
      const ts = (
        /** @type {TypeScript} */
        getTypeScript()
      );
      return (tsType.flags & ts.TypeFlags.Any) !== 0;
    }
    function isUnknown(tsType) {
      const ts = (
        /** @type {TypeScript} */
        getTypeScript()
      );
      return (tsType.flags & ts.TypeFlags.Unknown) !== 0;
    }
    function isNever(tsType) {
      const ts = (
        /** @type {TypeScript} */
        getTypeScript()
      );
      return (tsType.flags & ts.TypeFlags.Never) !== 0;
    }
    function isNull(tsType) {
      const ts = (
        /** @type {TypeScript} */
        getTypeScript()
      );
      return (tsType.flags & ts.TypeFlags.Null) !== 0;
    }
    function isStringLike(tsType) {
      const ts = (
        /** @type {TypeScript} */
        getTypeScript()
      );
      return (tsType.flags & ts.TypeFlags.StringLike) !== 0;
    }
    function isNumberLike(tsType) {
      const ts = (
        /** @type {TypeScript} */
        getTypeScript()
      );
      return (tsType.flags & ts.TypeFlags.NumberLike) !== 0;
    }
    function isBooleanLike(tsType) {
      const ts = (
        /** @type {TypeScript} */
        getTypeScript()
      );
      return (tsType.flags & ts.TypeFlags.BooleanLike) !== 0;
    }
    function isBigIntLike(tsType) {
      const ts = (
        /** @type {TypeScript} */
        getTypeScript()
      );
      return (tsType.flags & ts.TypeFlags.BigIntLike) !== 0;
    }
    function isReferenceObject(tsType) {
      const ts = (
        /** @type {TypeScript} */
        getTypeScript()
      );
      return isObject(tsType) && (tsType.objectFlags & ts.ObjectFlags.Reference) !== 0;
    }
    function isFunction(tsType) {
      const ts = (
        /** @type {TypeScript} */
        getTypeScript()
      );
      if (tsType.symbol && (tsType.symbol.flags & (ts.SymbolFlags.Function | ts.SymbolFlags.Method)) !== 0) {
        return true;
      }
      const signatures = tsType.getCallSignatures();
      return signatures.length > 0;
    }
  }
});

// node_modules/eslint-plugin-vue/lib/utils/ts-utils/ts-types.js
var require_ts_types = __commonJS({
  "node_modules/eslint-plugin-vue/lib/utils/ts-utils/ts-types.js"(exports, module) {
    var {
      getTypeScript,
      isAny,
      isUnknown,
      isNever,
      isNull,
      isObject,
      isFunction,
      isStringLike,
      isNumberLike,
      isBooleanLike,
      isBigIntLike,
      isArrayLikeObject,
      isReferenceObject
    } = require_typescript();
    module.exports = {
      getComponentPropsFromTypeDefineTypes,
      getComponentEmitsFromTypeDefineTypes,
      inferRuntimeTypeFromTypeNode
    };
    function getTSParserServices(context) {
      const sourceCode = context.getSourceCode();
      const tsNodeMap = sourceCode.parserServices.esTreeNodeToTSNodeMap;
      if (!tsNodeMap)
        return null;
      const hasFullTypeInformation = sourceCode.parserServices.hasFullTypeInformation !== false;
      const checker = hasFullTypeInformation && sourceCode.parserServices.program && sourceCode.parserServices.program.getTypeChecker() || null;
      if (!checker)
        return null;
      const ts = getTypeScript();
      if (!ts)
        return null;
      return {
        ts,
        tsNodeMap,
        checker
      };
    }
    function getComponentPropsFromTypeDefineTypes(context, propsNode) {
      const services = getTSParserServices(context);
      const tsNode = services && services.tsNodeMap.get(propsNode);
      const type = tsNode && services.checker.getTypeAtLocation(tsNode);
      if (!type || isAny(type) || isUnknown(type) || isNever(type) || isNull(type)) {
        return [
          {
            type: "unknown",
            propName: null,
            node: propsNode
          }
        ];
      }
      return [...extractRuntimeProps(type, tsNode, propsNode, services)];
    }
    function getComponentEmitsFromTypeDefineTypes(context, emitsNode) {
      const services = getTSParserServices(context);
      const tsNode = services && services.tsNodeMap.get(emitsNode);
      const type = tsNode && services.checker.getTypeAtLocation(tsNode);
      if (!type || isAny(type) || isUnknown(type) || isNever(type) || isNull(type)) {
        return [
          {
            type: "unknown",
            emitName: null,
            node: emitsNode
          }
        ];
      }
      return [...extractRuntimeEmits(type, tsNode, emitsNode, services)];
    }
    function inferRuntimeTypeFromTypeNode(context, node) {
      const services = getTSParserServices(context);
      const tsNode = services && services.tsNodeMap.get(node);
      const type = tsNode && services.checker.getTypeAtLocation(tsNode);
      if (!type) {
        return ["null"];
      }
      return inferRuntimeTypeInternal(type, services);
    }
    function* extractRuntimeProps(type, tsNode, propsNode, services) {
      const { ts, checker } = services;
      for (const property of type.getProperties()) {
        const isOptional = (property.flags & ts.SymbolFlags.Optional) !== 0;
        const name = property.getName();
        const type2 = checker.getTypeOfSymbolAtLocation(property, tsNode);
        yield {
          type: "infer-type",
          propName: name,
          required: !isOptional,
          node: propsNode,
          types: inferRuntimeTypeInternal(type2, services)
        };
      }
    }
    function inferRuntimeTypeInternal(type, services) {
      const { checker } = services;
      const types = /* @__PURE__ */ new Set();
      for (const targetType of iterateTypes(checker.getNonNullableType(type))) {
        if (isAny(targetType) || isUnknown(targetType) || isNever(targetType) || isNull(targetType)) {
          types.add("null");
        } else if (isStringLike(targetType)) {
          types.add("String");
        } else if (isNumberLike(targetType) || isBigIntLike(targetType)) {
          types.add("Number");
        } else if (isBooleanLike(targetType)) {
          types.add("Boolean");
        } else if (isFunction(targetType)) {
          types.add("Function");
        } else if (isArrayLikeObject(targetType) || targetType.isClassOrInterface() && ["Array", "ReadonlyArray"].includes(
          checker.getFullyQualifiedName(targetType.symbol)
        )) {
          types.add("Array");
        } else if (isObject(targetType)) {
          types.add("Object");
        }
      }
      if (types.size <= 0)
        types.add("null");
      return [...types];
    }
    function* extractRuntimeEmits(type, tsNode, emitsNode, services) {
      const { checker } = services;
      if (isFunction(type)) {
        for (const signature of type.getCallSignatures()) {
          const param = signature.getParameters()[0];
          if (!param) {
            yield {
              type: "unknown",
              emitName: null,
              node: emitsNode
            };
            continue;
          }
          const type2 = checker.getTypeOfSymbolAtLocation(param, tsNode);
          for (const targetType of iterateTypes(type2)) {
            yield targetType.isStringLiteral() ? {
              type: "infer-type",
              emitName: targetType.value,
              node: emitsNode
            } : {
              type: "unknown",
              emitName: null,
              node: emitsNode
            };
          }
        }
      } else if (isObject(type)) {
        for (const property of type.getProperties()) {
          const name = property.getName();
          yield {
            type: "infer-type",
            emitName: name,
            node: emitsNode
          };
        }
      } else {
        yield {
          type: "unknown",
          emitName: null,
          node: emitsNode
        };
      }
    }
    function* iterateTypes(type) {
      if (isReferenceObject(type) && type.target !== type) {
        yield* iterateTypes(type.target);
      } else if (type.isUnion() && !isBooleanLike(type)) {
        for (const t of type.types) {
          yield* iterateTypes(t);
        }
      } else {
        yield type;
      }
    }
  }
});

// node_modules/eslint-plugin-vue/lib/utils/ts-utils/ts-ast.js
var require_ts_ast = __commonJS({
  "node_modules/eslint-plugin-vue/lib/utils/ts-utils/ts-ast.js"(exports, module) {
    var { getScope } = require_scope();
    var { findVariable } = require_eslint_utils();
    var { inferRuntimeTypeFromTypeNode } = require_ts_types();
    var noop = Function.prototype;
    module.exports = {
      isTypeNode,
      flattenTypeNodes,
      isTSInterfaceBody,
      isTSTypeLiteral,
      isTSTypeLiteralOrTSFunctionType,
      extractRuntimeProps,
      extractRuntimeEmits
    };
    function isTypeNode(node) {
      if (node.type === "TSAbstractKeyword" || node.type === "TSAnyKeyword" || node.type === "TSAsyncKeyword" || node.type === "TSArrayType" || node.type === "TSBigIntKeyword" || node.type === "TSBooleanKeyword" || node.type === "TSConditionalType" || node.type === "TSConstructorType" || node.type === "TSDeclareKeyword" || node.type === "TSExportKeyword" || node.type === "TSFunctionType" || node.type === "TSImportType" || node.type === "TSIndexedAccessType" || node.type === "TSInferType" || node.type === "TSIntersectionType" || node.type === "TSIntrinsicKeyword" || node.type === "TSLiteralType" || node.type === "TSMappedType" || node.type === "TSNamedTupleMember" || node.type === "TSNeverKeyword" || node.type === "TSNullKeyword" || node.type === "TSNumberKeyword" || node.type === "TSObjectKeyword" || node.type === "TSOptionalType" || node.type === "TSQualifiedName" || node.type === "TSPrivateKeyword" || node.type === "TSProtectedKeyword" || node.type === "TSPublicKeyword" || node.type === "TSReadonlyKeyword" || node.type === "TSRestType" || node.type === "TSStaticKeyword" || node.type === "TSStringKeyword" || node.type === "TSSymbolKeyword" || node.type === "TSTemplateLiteralType" || node.type === "TSThisType" || node.type === "TSTupleType" || node.type === "TSTypeLiteral" || node.type === "TSTypeOperator" || node.type === "TSTypePredicate" || node.type === "TSTypeQuery" || node.type === "TSTypeReference" || node.type === "TSUndefinedKeyword" || node.type === "TSUnionType" || node.type === "TSUnknownKeyword" || node.type === "TSVoidKeyword") {
        const type2 = node.type;
        noop(type2);
        return true;
      }
      const type = node.type;
      noop(type);
      return false;
    }
    function isTSInterfaceBody(node) {
      return node.type === "TSInterfaceBody";
    }
    function isTSTypeLiteral(node) {
      return node.type === "TSTypeLiteral";
    }
    function isTSFunctionType(node) {
      return node.type === "TSFunctionType";
    }
    function isTSTypeLiteralOrTSFunctionType(node) {
      return isTSTypeLiteral(node) || isTSFunctionType(node);
    }
    function* extractRuntimeProps(context, node) {
      const members = node.type === "TSTypeLiteral" ? node.members : node.body;
      for (const member of members) {
        if (member.type === "TSPropertySignature" || member.type === "TSMethodSignature") {
          if (member.key.type !== "Identifier" && member.key.type !== "Literal") {
            yield {
              type: "unknown",
              propName: null,
              node: (
                /** @type {Expression} */
                member.key
              )
            };
            continue;
          }
          let types;
          if (member.type === "TSMethodSignature") {
            types = ["Function"];
          } else if (member.typeAnnotation) {
            types = inferRuntimeType(context, member.typeAnnotation.typeAnnotation);
          }
          yield {
            type: "type",
            key: (
              /** @type {Identifier | Literal} */
              member.key
            ),
            propName: member.key.type === "Identifier" ? member.key.name : `${member.key.value}`,
            node: (
              /** @type {TSPropertySignature | TSMethodSignature} */
              member
            ),
            required: !member.optional,
            types: types || [`null`]
          };
        }
      }
    }
    function* extractRuntimeEmits(node) {
      if (node.type === "TSFunctionType") {
        yield* extractEventNames(
          node.params[0],
          /** @type {TSFunctionType} */
          node
        );
        return;
      }
      const members = node.type === "TSTypeLiteral" ? node.members : node.body;
      for (const member of members) {
        if (member.type === "TSCallSignatureDeclaration") {
          yield* extractEventNames(
            member.params[0],
            /** @type {TSCallSignatureDeclaration} */
            member
          );
        } else if (member.type === "TSPropertySignature" || member.type === "TSMethodSignature") {
          if (member.key.type !== "Identifier" && member.key.type !== "Literal") {
            yield {
              type: "unknown",
              emitName: null,
              node: (
                /** @type {Expression} */
                member.key
              )
            };
            continue;
          }
          yield {
            type: "type",
            key: (
              /** @type {Identifier | Literal} */
              member.key
            ),
            emitName: member.key.type === "Identifier" ? member.key.name : `${member.key.value}`,
            node: (
              /** @type {TSPropertySignature | TSMethodSignature} */
              member
            )
          };
        }
      }
    }
    function* extractEventNames(eventName, member) {
      if (eventName && eventName.type === "Identifier" && eventName.typeAnnotation && eventName.typeAnnotation.type === "TSTypeAnnotation") {
        const typeNode = eventName.typeAnnotation.typeAnnotation;
        if (typeNode.type === "TSLiteralType" && typeNode.literal.type === "Literal") {
          const emitName = String(typeNode.literal.value);
          yield {
            type: "type",
            key: (
              /** @type {TSLiteralType} */
              typeNode
            ),
            emitName,
            node: member
          };
        } else if (typeNode.type === "TSUnionType") {
          for (const t of typeNode.types) {
            if (t.type === "TSLiteralType" && t.literal.type === "Literal") {
              const emitName = String(t.literal.value);
              yield {
                type: "type",
                key: (
                  /** @type {TSLiteralType} */
                  t
                ),
                emitName,
                node: member
              };
            }
          }
        }
      }
    }
    function flattenTypeNodes(context, node) {
      const traversed = /* @__PURE__ */ new Map();
      return [...flattenImpl(node)];
      function* flattenImpl(node2) {
        if (node2.type === "TSUnionType" || node2.type === "TSIntersectionType") {
          for (const typeNode of node2.types) {
            yield* flattenImpl(typeNode);
          }
          return;
        }
        if (node2.type === "TSTypeReference" && node2.typeName.type === "Identifier") {
          const refName = node2.typeName.name;
          const variable = findVariable(
            getScope(
              context,
              /** @type {any} */
              node2
            ),
            refName
          );
          if (variable && variable.defs.length === 1) {
            const defNode = (
              /** @type {TSESTreeNode} */
              variable.defs[0].node
            );
            if (defNode.type === "TSInterfaceDeclaration") {
              yield defNode.body;
              return;
            } else if (defNode.type === "TSTypeAliasDeclaration") {
              const typeAnnotation = defNode.typeAnnotation;
              let traversedData = traversed.get(typeAnnotation);
              if (traversedData) {
                const copy = [...traversedData.nodes];
                yield* copy;
                if (!traversedData.finished) {
                  yield typeAnnotation;
                }
                return;
              }
              traversedData = { nodes: /* @__PURE__ */ new Set(), finished: false };
              traversed.set(typeAnnotation, traversedData);
              for (const e of flattenImpl(typeAnnotation)) {
                traversedData.nodes.add(e);
              }
              traversedData.finished = true;
              yield* traversedData.nodes;
              return;
            }
          }
        }
        yield node2;
      }
    }
    function inferRuntimeType(context, node, checked = /* @__PURE__ */ new Set()) {
      switch (node.type) {
        case "TSStringKeyword":
        case "TSTemplateLiteralType": {
          return ["String"];
        }
        case "TSNumberKeyword": {
          return ["Number"];
        }
        case "TSBooleanKeyword": {
          return ["Boolean"];
        }
        case "TSObjectKeyword": {
          return ["Object"];
        }
        case "TSTypeLiteral": {
          return inferTypeLiteralType(node);
        }
        case "TSFunctionType": {
          return ["Function"];
        }
        case "TSArrayType":
        case "TSTupleType": {
          return ["Array"];
        }
        case "TSSymbolKeyword": {
          return ["Symbol"];
        }
        case "TSLiteralType": {
          if (node.literal.type === "Literal") {
            switch (typeof node.literal.value) {
              case "boolean": {
                return ["Boolean"];
              }
              case "string": {
                return ["String"];
              }
              case "number":
              case "bigint": {
                return ["Number"];
              }
            }
            if (node.literal.value instanceof RegExp) {
              return ["RegExp"];
            }
          }
          return inferRuntimeTypeFromTypeNode(
            context,
            /** @type {TypeNode} */
            node
          );
        }
        case "TSTypeReference": {
          if (node.typeName.type === "Identifier") {
            const variable = findVariable(
              getScope(
                context,
                /** @type {any} */
                node
              ),
              node.typeName.name
            );
            if (variable && variable.defs.length === 1) {
              const defNode = (
                /** @type {TSESTreeNode} */
                variable.defs[0].node
              );
              if (defNode.type === "TSInterfaceDeclaration") {
                return [`Object`];
              }
              if (defNode.type === "TSTypeAliasDeclaration") {
                const typeAnnotation = defNode.typeAnnotation;
                if (!checked.has(typeAnnotation)) {
                  checked.add(typeAnnotation);
                  return inferRuntimeType(context, typeAnnotation, checked);
                }
              }
              if (defNode.type === "TSEnumDeclaration") {
                return inferEnumType(context, defNode);
              }
            }
            for (const name of [
              node.typeName.name,
              ...node.typeName.name.startsWith("Readonly") ? [node.typeName.name.slice(8)] : []
            ]) {
              switch (name) {
                case "Array":
                case "Function":
                case "Object":
                case "Set":
                case "Map":
                case "WeakSet":
                case "WeakMap":
                case "Date": {
                  return [name];
                }
              }
            }
            switch (node.typeName.name) {
              case "Record":
              case "Partial":
              case "Readonly":
              case "Pick":
              case "Omit":
              case "Required":
              case "InstanceType": {
                return ["Object"];
              }
              case "Uppercase":
              case "Lowercase":
              case "Capitalize":
              case "Uncapitalize": {
                return ["String"];
              }
              case "Parameters":
              case "ConstructorParameters": {
                return ["Array"];
              }
              case "NonNullable": {
                const typeArguments = "typeArguments" in node ? node.typeArguments : (
                  /** @type {any} typescript-eslint v5 */
                  node.typeParameters
                );
                if (typeArguments && typeArguments.params[0]) {
                  return inferRuntimeType(
                    context,
                    typeArguments.params[0],
                    checked
                  ).filter((t) => t !== "null");
                }
                break;
              }
              case "Extract": {
                const typeArguments = "typeArguments" in node ? node.typeArguments : (
                  /** @type {any} typescript-eslint v5 */
                  node.typeParameters
                );
                if (typeArguments && typeArguments.params[1]) {
                  return inferRuntimeType(context, typeArguments.params[1], checked);
                }
                break;
              }
              case "Exclude":
              case "OmitThisParameter": {
                const typeArguments = "typeArguments" in node ? node.typeArguments : (
                  /** @type {any} typescript-eslint v5 */
                  node.typeParameters
                );
                if (typeArguments && typeArguments.params[0]) {
                  return inferRuntimeType(context, typeArguments.params[0], checked);
                }
                break;
              }
            }
          }
          return inferRuntimeTypeFromTypeNode(
            context,
            /** @type {TypeNode} */
            node
          );
        }
        case "TSUnionType":
        case "TSIntersectionType": {
          return inferUnionType(node);
        }
        default: {
          return inferRuntimeTypeFromTypeNode(
            context,
            /** @type {TypeNode} */
            node
          );
        }
      }
      function inferUnionType(node2) {
        const types = /* @__PURE__ */ new Set();
        for (const t of node2.types) {
          for (const tt of inferRuntimeType(context, t, checked)) {
            types.add(tt);
          }
        }
        return [...types];
      }
    }
    function inferTypeLiteralType(node) {
      const types = /* @__PURE__ */ new Set();
      for (const m of node.members) {
        switch (m.type) {
          case "TSCallSignatureDeclaration":
          case "TSConstructSignatureDeclaration": {
            types.add("Function");
            break;
          }
          default: {
            types.add("Object");
          }
        }
      }
      return types.size > 0 ? [...types] : ["Object"];
    }
    function inferEnumType(context, node) {
      const types = /* @__PURE__ */ new Set();
      for (const m of node.members) {
        if (m.initializer) {
          if (m.initializer.type === "Literal") {
            switch (typeof m.initializer.value) {
              case "string": {
                types.add("String");
                break;
              }
              case "number":
              case "bigint": {
                types.add("Number");
                break;
              }
              case "boolean": {
                types.add("Boolean");
                break;
              }
            }
          } else {
            for (const type of inferRuntimeTypeFromTypeNode(
              context,
              /** @type {Expression} */
              m.initializer
            )) {
              types.add(type);
            }
          }
        }
      }
      return types.size > 0 ? [...types] : ["Number"];
    }
  }
});
export default require_ts_ast();
//# sourceMappingURL=eslint-plugin-vue_lib_utils_ts-utils_ts-ast__js.js.map
