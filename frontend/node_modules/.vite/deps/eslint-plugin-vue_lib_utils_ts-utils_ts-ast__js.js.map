{
  "version": 3,
  "sources": ["../../eslint-plugin-vue/lib/utils/scope.js", "../../eslint-visitor-keys/dist/eslint-visitor-keys.cjs", "../../@eslint-community/eslint-utils/src/get-innermost-scope.mjs", "../../@eslint-community/eslint-utils/src/find-variable.mjs", "../../@eslint-community/eslint-utils/src/token-predicate.mjs", "../../@eslint-community/eslint-utils/src/get-function-head-location.mjs", "../../@eslint-community/eslint-utils/src/get-static-value.mjs", "../../@eslint-community/eslint-utils/src/get-string-if-constant.mjs", "../../@eslint-community/eslint-utils/src/get-property-name.mjs", "../../@eslint-community/eslint-utils/src/get-function-name-with-kind.mjs", "../../@eslint-community/eslint-utils/src/has-side-effect.mjs", "../../@eslint-community/eslint-utils/src/is-parenthesized.mjs", "../../@eslint-community/eslint-utils/src/pattern-matcher.mjs", "../../@eslint-community/eslint-utils/src/reference-tracker.mjs", "../../@eslint-community/eslint-utils/src/index.mjs", "../../eslint-plugin-vue/lib/utils/ts-utils/typescript.js", "../../eslint-plugin-vue/lib/utils/ts-utils/ts-types.js", "../../eslint-plugin-vue/lib/utils/ts-utils/ts-ast.js"],
  "sourcesContent": ["module.exports = {\n  getScope\n}\n\n/**\n * Gets the scope for the current node\n * @param {RuleContext} context The rule context\n * @param {ESNode} currentNode The node to get the scope of\n * @returns { import('eslint').Scope.Scope } The scope information for this node\n */\nfunction getScope(context, currentNode) {\n  // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.\n  const inner = currentNode.type !== 'Program'\n  const scopeManager = context.getSourceCode().scopeManager\n\n  /** @type {ESNode | null} */\n  let node = currentNode\n  for (; node; node = /** @type {ESNode | null} */ (node.parent)) {\n    const scope = scopeManager.acquire(node, inner)\n\n    if (scope) {\n      if (scope.type === 'function-expression-name') {\n        return scope.childScopes[0]\n      }\n      return scope\n    }\n  }\n\n  return scopeManager.scopes[0]\n}\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * @typedef {{ readonly [type: string]: ReadonlyArray<string> }} VisitorKeys\n */\n\n/**\n * @type {VisitorKeys}\n */\nconst KEYS = {\n    ArrayExpression: [\n        \"elements\"\n    ],\n    ArrayPattern: [\n        \"elements\"\n    ],\n    ArrowFunctionExpression: [\n        \"params\",\n        \"body\"\n    ],\n    AssignmentExpression: [\n        \"left\",\n        \"right\"\n    ],\n    AssignmentPattern: [\n        \"left\",\n        \"right\"\n    ],\n    AwaitExpression: [\n        \"argument\"\n    ],\n    BinaryExpression: [\n        \"left\",\n        \"right\"\n    ],\n    BlockStatement: [\n        \"body\"\n    ],\n    BreakStatement: [\n        \"label\"\n    ],\n    CallExpression: [\n        \"callee\",\n        \"arguments\"\n    ],\n    CatchClause: [\n        \"param\",\n        \"body\"\n    ],\n    ChainExpression: [\n        \"expression\"\n    ],\n    ClassBody: [\n        \"body\"\n    ],\n    ClassDeclaration: [\n        \"id\",\n        \"superClass\",\n        \"body\"\n    ],\n    ClassExpression: [\n        \"id\",\n        \"superClass\",\n        \"body\"\n    ],\n    ConditionalExpression: [\n        \"test\",\n        \"consequent\",\n        \"alternate\"\n    ],\n    ContinueStatement: [\n        \"label\"\n    ],\n    DebuggerStatement: [],\n    DoWhileStatement: [\n        \"body\",\n        \"test\"\n    ],\n    EmptyStatement: [],\n    ExperimentalRestProperty: [\n        \"argument\"\n    ],\n    ExperimentalSpreadProperty: [\n        \"argument\"\n    ],\n    ExportAllDeclaration: [\n        \"exported\",\n        \"source\"\n    ],\n    ExportDefaultDeclaration: [\n        \"declaration\"\n    ],\n    ExportNamedDeclaration: [\n        \"declaration\",\n        \"specifiers\",\n        \"source\"\n    ],\n    ExportSpecifier: [\n        \"exported\",\n        \"local\"\n    ],\n    ExpressionStatement: [\n        \"expression\"\n    ],\n    ForInStatement: [\n        \"left\",\n        \"right\",\n        \"body\"\n    ],\n    ForOfStatement: [\n        \"left\",\n        \"right\",\n        \"body\"\n    ],\n    ForStatement: [\n        \"init\",\n        \"test\",\n        \"update\",\n        \"body\"\n    ],\n    FunctionDeclaration: [\n        \"id\",\n        \"params\",\n        \"body\"\n    ],\n    FunctionExpression: [\n        \"id\",\n        \"params\",\n        \"body\"\n    ],\n    Identifier: [],\n    IfStatement: [\n        \"test\",\n        \"consequent\",\n        \"alternate\"\n    ],\n    ImportDeclaration: [\n        \"specifiers\",\n        \"source\"\n    ],\n    ImportDefaultSpecifier: [\n        \"local\"\n    ],\n    ImportExpression: [\n        \"source\"\n    ],\n    ImportNamespaceSpecifier: [\n        \"local\"\n    ],\n    ImportSpecifier: [\n        \"imported\",\n        \"local\"\n    ],\n    JSXAttribute: [\n        \"name\",\n        \"value\"\n    ],\n    JSXClosingElement: [\n        \"name\"\n    ],\n    JSXClosingFragment: [],\n    JSXElement: [\n        \"openingElement\",\n        \"children\",\n        \"closingElement\"\n    ],\n    JSXEmptyExpression: [],\n    JSXExpressionContainer: [\n        \"expression\"\n    ],\n    JSXFragment: [\n        \"openingFragment\",\n        \"children\",\n        \"closingFragment\"\n    ],\n    JSXIdentifier: [],\n    JSXMemberExpression: [\n        \"object\",\n        \"property\"\n    ],\n    JSXNamespacedName: [\n        \"namespace\",\n        \"name\"\n    ],\n    JSXOpeningElement: [\n        \"name\",\n        \"attributes\"\n    ],\n    JSXOpeningFragment: [],\n    JSXSpreadAttribute: [\n        \"argument\"\n    ],\n    JSXSpreadChild: [\n        \"expression\"\n    ],\n    JSXText: [],\n    LabeledStatement: [\n        \"label\",\n        \"body\"\n    ],\n    Literal: [],\n    LogicalExpression: [\n        \"left\",\n        \"right\"\n    ],\n    MemberExpression: [\n        \"object\",\n        \"property\"\n    ],\n    MetaProperty: [\n        \"meta\",\n        \"property\"\n    ],\n    MethodDefinition: [\n        \"key\",\n        \"value\"\n    ],\n    NewExpression: [\n        \"callee\",\n        \"arguments\"\n    ],\n    ObjectExpression: [\n        \"properties\"\n    ],\n    ObjectPattern: [\n        \"properties\"\n    ],\n    PrivateIdentifier: [],\n    Program: [\n        \"body\"\n    ],\n    Property: [\n        \"key\",\n        \"value\"\n    ],\n    PropertyDefinition: [\n        \"key\",\n        \"value\"\n    ],\n    RestElement: [\n        \"argument\"\n    ],\n    ReturnStatement: [\n        \"argument\"\n    ],\n    SequenceExpression: [\n        \"expressions\"\n    ],\n    SpreadElement: [\n        \"argument\"\n    ],\n    StaticBlock: [\n        \"body\"\n    ],\n    Super: [],\n    SwitchCase: [\n        \"test\",\n        \"consequent\"\n    ],\n    SwitchStatement: [\n        \"discriminant\",\n        \"cases\"\n    ],\n    TaggedTemplateExpression: [\n        \"tag\",\n        \"quasi\"\n    ],\n    TemplateElement: [],\n    TemplateLiteral: [\n        \"quasis\",\n        \"expressions\"\n    ],\n    ThisExpression: [],\n    ThrowStatement: [\n        \"argument\"\n    ],\n    TryStatement: [\n        \"block\",\n        \"handler\",\n        \"finalizer\"\n    ],\n    UnaryExpression: [\n        \"argument\"\n    ],\n    UpdateExpression: [\n        \"argument\"\n    ],\n    VariableDeclaration: [\n        \"declarations\"\n    ],\n    VariableDeclarator: [\n        \"id\",\n        \"init\"\n    ],\n    WhileStatement: [\n        \"test\",\n        \"body\"\n    ],\n    WithStatement: [\n        \"object\",\n        \"body\"\n    ],\n    YieldExpression: [\n        \"argument\"\n    ]\n};\n\n// Types.\nconst NODE_TYPES = Object.keys(KEYS);\n\n// Freeze the keys.\nfor (const type of NODE_TYPES) {\n    Object.freeze(KEYS[type]);\n}\nObject.freeze(KEYS);\n\n/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * See LICENSE file in root directory for full license.\n */\n\n/**\n * @typedef {import('./visitor-keys.js').VisitorKeys} VisitorKeys\n */\n\n// List to ignore keys.\nconst KEY_BLACKLIST = new Set([\n    \"parent\",\n    \"leadingComments\",\n    \"trailingComments\"\n]);\n\n/**\n * Check whether a given key should be used or not.\n * @param {string} key The key to check.\n * @returns {boolean} `true` if the key should be used.\n */\nfunction filterKey(key) {\n    return !KEY_BLACKLIST.has(key) && key[0] !== \"_\";\n}\n\n/**\n * Get visitor keys of a given node.\n * @param {object} node The AST node to get keys.\n * @returns {readonly string[]} Visitor keys of the node.\n */\nfunction getKeys(node) {\n    return Object.keys(node).filter(filterKey);\n}\n\n// Disable valid-jsdoc rule because it reports syntax error on the type of @returns.\n// eslint-disable-next-line valid-jsdoc\n/**\n * Make the union set with `KEYS` and given keys.\n * @param {VisitorKeys} additionalKeys The additional keys.\n * @returns {VisitorKeys} The union set.\n */\nfunction unionWith(additionalKeys) {\n    const retv = /** @type {{\n        [type: string]: ReadonlyArray<string>\n    }} */ (Object.assign({}, KEYS));\n\n    for (const type of Object.keys(additionalKeys)) {\n        if (Object.prototype.hasOwnProperty.call(retv, type)) {\n            const keys = new Set(additionalKeys[type]);\n\n            for (const key of retv[type]) {\n                keys.add(key);\n            }\n\n            retv[type] = Object.freeze(Array.from(keys));\n        } else {\n            retv[type] = Object.freeze(Array.from(additionalKeys[type]));\n        }\n    }\n\n    return Object.freeze(retv);\n}\n\nexports.KEYS = KEYS;\nexports.getKeys = getKeys;\nexports.unionWith = unionWith;\n", "/**\n * Get the innermost scope which contains a given location.\n * @param {Scope} initialScope The initial scope to search.\n * @param {Node} node The location to search.\n * @returns {Scope} The innermost scope.\n */\nexport function getInnermostScope(initialScope, node) {\n    const location = node.range[0]\n\n    let scope = initialScope\n    let found = false\n    do {\n        found = false\n        for (const childScope of scope.childScopes) {\n            const range = childScope.block.range\n\n            if (range[0] <= location && location < range[1]) {\n                scope = childScope\n                found = true\n                break\n            }\n        }\n    } while (found)\n\n    return scope\n}\n", "import { getInnermostScope } from \"./get-innermost-scope.mjs\"\n\n/**\n * Find the variable of a given name.\n * @param {Scope} initialScope The scope to start finding.\n * @param {string|Node} nameOrNode The variable name to find. If this is a Node object then it should be an Identifier node.\n * @returns {Variable|null} The found variable or null.\n */\nexport function findVariable(initialScope, nameOrNode) {\n    let name = \"\"\n    let scope = initialScope\n\n    if (typeof nameOrNode === \"string\") {\n        name = nameOrNode\n    } else {\n        name = nameOrNode.name\n        scope = getInnermostScope(scope, nameOrNode)\n    }\n\n    while (scope != null) {\n        const variable = scope.set.get(name)\n        if (variable != null) {\n            return variable\n        }\n        scope = scope.upper\n    }\n\n    return null\n}\n", "/**\n * Negate the result of `this` calling.\n * @param {Token} token The token to check.\n * @returns {boolean} `true` if the result of `this(token)` is `false`.\n */\nfunction negate0(token) {\n    return !this(token) //eslint-disable-line no-invalid-this\n}\n\n/**\n * Creates the negate function of the given function.\n * @param {function(Token):boolean} f - The function to negate.\n * @returns {function(Token):boolean} Negated function.\n */\nfunction negate(f) {\n    return negate0.bind(f)\n}\n\n/**\n * Checks if the given token is a PunctuatorToken with the given value\n * @param {Token} token - The token to check.\n * @param {string} value - The value to check.\n * @returns {boolean} `true` if the token is a PunctuatorToken with the given value.\n */\nfunction isPunctuatorTokenWithValue(token, value) {\n    return token.type === \"Punctuator\" && token.value === value\n}\n\n/**\n * Checks if the given token is an arrow token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an arrow token.\n */\nexport function isArrowToken(token) {\n    return isPunctuatorTokenWithValue(token, \"=>\")\n}\n\n/**\n * Checks if the given token is a comma token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a comma token.\n */\nexport function isCommaToken(token) {\n    return isPunctuatorTokenWithValue(token, \",\")\n}\n\n/**\n * Checks if the given token is a semicolon token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a semicolon token.\n */\nexport function isSemicolonToken(token) {\n    return isPunctuatorTokenWithValue(token, \";\")\n}\n\n/**\n * Checks if the given token is a colon token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a colon token.\n */\nexport function isColonToken(token) {\n    return isPunctuatorTokenWithValue(token, \":\")\n}\n\n/**\n * Checks if the given token is an opening parenthesis token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening parenthesis token.\n */\nexport function isOpeningParenToken(token) {\n    return isPunctuatorTokenWithValue(token, \"(\")\n}\n\n/**\n * Checks if the given token is a closing parenthesis token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing parenthesis token.\n */\nexport function isClosingParenToken(token) {\n    return isPunctuatorTokenWithValue(token, \")\")\n}\n\n/**\n * Checks if the given token is an opening square bracket token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening square bracket token.\n */\nexport function isOpeningBracketToken(token) {\n    return isPunctuatorTokenWithValue(token, \"[\")\n}\n\n/**\n * Checks if the given token is a closing square bracket token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing square bracket token.\n */\nexport function isClosingBracketToken(token) {\n    return isPunctuatorTokenWithValue(token, \"]\")\n}\n\n/**\n * Checks if the given token is an opening brace token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening brace token.\n */\nexport function isOpeningBraceToken(token) {\n    return isPunctuatorTokenWithValue(token, \"{\")\n}\n\n/**\n * Checks if the given token is a closing brace token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing brace token.\n */\nexport function isClosingBraceToken(token) {\n    return isPunctuatorTokenWithValue(token, \"}\")\n}\n\n/**\n * Checks if the given token is a comment token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a comment token.\n */\nexport function isCommentToken(token) {\n    return [\"Block\", \"Line\", \"Shebang\"].includes(token.type)\n}\n\nexport const isNotArrowToken = negate(isArrowToken)\nexport const isNotCommaToken = negate(isCommaToken)\nexport const isNotSemicolonToken = negate(isSemicolonToken)\nexport const isNotColonToken = negate(isColonToken)\nexport const isNotOpeningParenToken = negate(isOpeningParenToken)\nexport const isNotClosingParenToken = negate(isClosingParenToken)\nexport const isNotOpeningBracketToken = negate(isOpeningBracketToken)\nexport const isNotClosingBracketToken = negate(isClosingBracketToken)\nexport const isNotOpeningBraceToken = negate(isOpeningBraceToken)\nexport const isNotClosingBraceToken = negate(isClosingBraceToken)\nexport const isNotCommentToken = negate(isCommentToken)\n", "import { isArrowToken, isOpeningParenToken } from \"./token-predicate.mjs\"\n\n/**\n * Get the `(` token of the given function node.\n * @param {Node} node - The function node to get.\n * @param {SourceCode} sourceCode - The source code object to get tokens.\n * @returns {Token} `(` token.\n */\nfunction getOpeningParenOfParams(node, sourceCode) {\n    return node.id\n        ? sourceCode.getTokenAfter(node.id, isOpeningParenToken)\n        : sourceCode.getFirstToken(node, isOpeningParenToken)\n}\n\n/**\n * Get the location of the given function node for reporting.\n * @param {Node} node - The function node to get.\n * @param {SourceCode} sourceCode - The source code object to get tokens.\n * @returns {string} The location of the function node for reporting.\n */\nexport function getFunctionHeadLocation(node, sourceCode) {\n    const parent = node.parent\n    let start = null\n    let end = null\n\n    if (node.type === \"ArrowFunctionExpression\") {\n        const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken)\n\n        start = arrowToken.loc.start\n        end = arrowToken.loc.end\n    } else if (\n        parent.type === \"Property\" ||\n        parent.type === \"MethodDefinition\" ||\n        parent.type === \"PropertyDefinition\"\n    ) {\n        start = parent.loc.start\n        end = getOpeningParenOfParams(node, sourceCode).loc.start\n    } else {\n        start = node.loc.start\n        end = getOpeningParenOfParams(node, sourceCode).loc.start\n    }\n\n    return {\n        start: { ...start },\n        end: { ...end },\n    }\n}\n", "/* globals globalThis, global, self, window */\n\nimport { findVariable } from \"./find-variable.mjs\"\n\nconst globalObject =\n    typeof globalThis !== \"undefined\"\n        ? globalThis\n        : typeof self !== \"undefined\"\n        ? self\n        : typeof window !== \"undefined\"\n        ? window\n        : typeof global !== \"undefined\"\n        ? global\n        : {}\n\nconst builtinNames = Object.freeze(\n    new Set([\n        \"Array\",\n        \"ArrayBuffer\",\n        \"BigInt\",\n        \"BigInt64Array\",\n        \"BigUint64Array\",\n        \"Boolean\",\n        \"DataView\",\n        \"Date\",\n        \"decodeURI\",\n        \"decodeURIComponent\",\n        \"encodeURI\",\n        \"encodeURIComponent\",\n        \"escape\",\n        \"Float32Array\",\n        \"Float64Array\",\n        \"Function\",\n        \"Infinity\",\n        \"Int16Array\",\n        \"Int32Array\",\n        \"Int8Array\",\n        \"isFinite\",\n        \"isNaN\",\n        \"isPrototypeOf\",\n        \"JSON\",\n        \"Map\",\n        \"Math\",\n        \"NaN\",\n        \"Number\",\n        \"Object\",\n        \"parseFloat\",\n        \"parseInt\",\n        \"Promise\",\n        \"Proxy\",\n        \"Reflect\",\n        \"RegExp\",\n        \"Set\",\n        \"String\",\n        \"Symbol\",\n        \"Uint16Array\",\n        \"Uint32Array\",\n        \"Uint8Array\",\n        \"Uint8ClampedArray\",\n        \"undefined\",\n        \"unescape\",\n        \"WeakMap\",\n        \"WeakSet\",\n    ]),\n)\nconst callAllowed = new Set(\n    [\n        Array.isArray,\n        Array.of,\n        Array.prototype.at,\n        Array.prototype.concat,\n        Array.prototype.entries,\n        Array.prototype.every,\n        Array.prototype.filter,\n        Array.prototype.find,\n        Array.prototype.findIndex,\n        Array.prototype.flat,\n        Array.prototype.includes,\n        Array.prototype.indexOf,\n        Array.prototype.join,\n        Array.prototype.keys,\n        Array.prototype.lastIndexOf,\n        Array.prototype.slice,\n        Array.prototype.some,\n        Array.prototype.toString,\n        Array.prototype.values,\n        typeof BigInt === \"function\" ? BigInt : undefined,\n        Boolean,\n        Date,\n        Date.parse,\n        decodeURI,\n        decodeURIComponent,\n        encodeURI,\n        encodeURIComponent,\n        escape,\n        isFinite,\n        isNaN,\n        isPrototypeOf,\n        Map,\n        Map.prototype.entries,\n        Map.prototype.get,\n        Map.prototype.has,\n        Map.prototype.keys,\n        Map.prototype.values,\n        ...Object.getOwnPropertyNames(Math)\n            .filter((k) => k !== \"random\")\n            .map((k) => Math[k])\n            .filter((f) => typeof f === \"function\"),\n        Number,\n        Number.isFinite,\n        Number.isNaN,\n        Number.parseFloat,\n        Number.parseInt,\n        Number.prototype.toExponential,\n        Number.prototype.toFixed,\n        Number.prototype.toPrecision,\n        Number.prototype.toString,\n        Object,\n        Object.entries,\n        Object.is,\n        Object.isExtensible,\n        Object.isFrozen,\n        Object.isSealed,\n        Object.keys,\n        Object.values,\n        parseFloat,\n        parseInt,\n        RegExp,\n        Set,\n        Set.prototype.entries,\n        Set.prototype.has,\n        Set.prototype.keys,\n        Set.prototype.values,\n        String,\n        String.fromCharCode,\n        String.fromCodePoint,\n        String.raw,\n        String.prototype.at,\n        String.prototype.charAt,\n        String.prototype.charCodeAt,\n        String.prototype.codePointAt,\n        String.prototype.concat,\n        String.prototype.endsWith,\n        String.prototype.includes,\n        String.prototype.indexOf,\n        String.prototype.lastIndexOf,\n        String.prototype.normalize,\n        String.prototype.padEnd,\n        String.prototype.padStart,\n        String.prototype.slice,\n        String.prototype.startsWith,\n        String.prototype.substr,\n        String.prototype.substring,\n        String.prototype.toLowerCase,\n        String.prototype.toString,\n        String.prototype.toUpperCase,\n        String.prototype.trim,\n        String.prototype.trimEnd,\n        String.prototype.trimLeft,\n        String.prototype.trimRight,\n        String.prototype.trimStart,\n        Symbol.for,\n        Symbol.keyFor,\n        unescape,\n    ].filter((f) => typeof f === \"function\"),\n)\nconst callPassThrough = new Set([\n    Object.freeze,\n    Object.preventExtensions,\n    Object.seal,\n])\n\n/** @type {ReadonlyArray<readonly [Function, ReadonlySet<string>]>} */\nconst getterAllowed = [\n    [Map, new Set([\"size\"])],\n    [\n        RegExp,\n        new Set([\n            \"dotAll\",\n            \"flags\",\n            \"global\",\n            \"hasIndices\",\n            \"ignoreCase\",\n            \"multiline\",\n            \"source\",\n            \"sticky\",\n            \"unicode\",\n        ]),\n    ],\n    [Set, new Set([\"size\"])],\n]\n\n/**\n * Get the property descriptor.\n * @param {object} object The object to get.\n * @param {string|number|symbol} name The property name to get.\n */\nfunction getPropertyDescriptor(object, name) {\n    let x = object\n    while ((typeof x === \"object\" || typeof x === \"function\") && x !== null) {\n        const d = Object.getOwnPropertyDescriptor(x, name)\n        if (d) {\n            return d\n        }\n        x = Object.getPrototypeOf(x)\n    }\n    return null\n}\n\n/**\n * Check if a property is getter or not.\n * @param {object} object The object to check.\n * @param {string|number|symbol} name The property name to check.\n */\nfunction isGetter(object, name) {\n    const d = getPropertyDescriptor(object, name)\n    return d != null && d.get != null\n}\n\n/**\n * Get the element values of a given node list.\n * @param {Node[]} nodeList The node list to get values.\n * @param {Scope|undefined} initialScope The initial scope to find variables.\n * @returns {any[]|null} The value list if all nodes are constant. Otherwise, null.\n */\nfunction getElementValues(nodeList, initialScope) {\n    const valueList = []\n\n    for (let i = 0; i < nodeList.length; ++i) {\n        const elementNode = nodeList[i]\n\n        if (elementNode == null) {\n            valueList.length = i + 1\n        } else if (elementNode.type === \"SpreadElement\") {\n            const argument = getStaticValueR(elementNode.argument, initialScope)\n            if (argument == null) {\n                return null\n            }\n            valueList.push(...argument.value)\n        } else {\n            const element = getStaticValueR(elementNode, initialScope)\n            if (element == null) {\n                return null\n            }\n            valueList.push(element.value)\n        }\n    }\n\n    return valueList\n}\n\n/**\n * Returns whether the given variable is never written to after initialization.\n * @param {import(\"eslint\").Scope.Variable} variable\n * @returns {boolean}\n */\nfunction isEffectivelyConst(variable) {\n    const refs = variable.references\n\n    const inits = refs.filter((r) => r.init).length\n    const reads = refs.filter((r) => r.isReadOnly()).length\n    if (inits === 1 && reads + inits === refs.length) {\n        // there is only one init and all other references only read\n        return true\n    }\n    return false\n}\n\nconst operations = Object.freeze({\n    ArrayExpression(node, initialScope) {\n        const elements = getElementValues(node.elements, initialScope)\n        return elements != null ? { value: elements } : null\n    },\n\n    AssignmentExpression(node, initialScope) {\n        if (node.operator === \"=\") {\n            return getStaticValueR(node.right, initialScope)\n        }\n        return null\n    },\n\n    //eslint-disable-next-line complexity\n    BinaryExpression(node, initialScope) {\n        if (node.operator === \"in\" || node.operator === \"instanceof\") {\n            // Not supported.\n            return null\n        }\n\n        const left = getStaticValueR(node.left, initialScope)\n        const right = getStaticValueR(node.right, initialScope)\n        if (left != null && right != null) {\n            switch (node.operator) {\n                case \"==\":\n                    return { value: left.value == right.value } //eslint-disable-line eqeqeq\n                case \"!=\":\n                    return { value: left.value != right.value } //eslint-disable-line eqeqeq\n                case \"===\":\n                    return { value: left.value === right.value }\n                case \"!==\":\n                    return { value: left.value !== right.value }\n                case \"<\":\n                    return { value: left.value < right.value }\n                case \"<=\":\n                    return { value: left.value <= right.value }\n                case \">\":\n                    return { value: left.value > right.value }\n                case \">=\":\n                    return { value: left.value >= right.value }\n                case \"<<\":\n                    return { value: left.value << right.value }\n                case \">>\":\n                    return { value: left.value >> right.value }\n                case \">>>\":\n                    return { value: left.value >>> right.value }\n                case \"+\":\n                    return { value: left.value + right.value }\n                case \"-\":\n                    return { value: left.value - right.value }\n                case \"*\":\n                    return { value: left.value * right.value }\n                case \"/\":\n                    return { value: left.value / right.value }\n                case \"%\":\n                    return { value: left.value % right.value }\n                case \"**\":\n                    return { value: left.value ** right.value }\n                case \"|\":\n                    return { value: left.value | right.value }\n                case \"^\":\n                    return { value: left.value ^ right.value }\n                case \"&\":\n                    return { value: left.value & right.value }\n\n                // no default\n            }\n        }\n\n        return null\n    },\n\n    CallExpression(node, initialScope) {\n        const calleeNode = node.callee\n        const args = getElementValues(node.arguments, initialScope)\n\n        if (args != null) {\n            if (calleeNode.type === \"MemberExpression\") {\n                if (calleeNode.property.type === \"PrivateIdentifier\") {\n                    return null\n                }\n                const object = getStaticValueR(calleeNode.object, initialScope)\n                if (object != null) {\n                    if (\n                        object.value == null &&\n                        (object.optional || node.optional)\n                    ) {\n                        return { value: undefined, optional: true }\n                    }\n                    const property = getStaticPropertyNameValue(\n                        calleeNode,\n                        initialScope,\n                    )\n\n                    if (property != null) {\n                        const receiver = object.value\n                        const methodName = property.value\n                        if (callAllowed.has(receiver[methodName])) {\n                            return { value: receiver[methodName](...args) }\n                        }\n                        if (callPassThrough.has(receiver[methodName])) {\n                            return { value: args[0] }\n                        }\n                    }\n                }\n            } else {\n                const callee = getStaticValueR(calleeNode, initialScope)\n                if (callee != null) {\n                    if (callee.value == null && node.optional) {\n                        return { value: undefined, optional: true }\n                    }\n                    const func = callee.value\n                    if (callAllowed.has(func)) {\n                        return { value: func(...args) }\n                    }\n                    if (callPassThrough.has(func)) {\n                        return { value: args[0] }\n                    }\n                }\n            }\n        }\n\n        return null\n    },\n\n    ConditionalExpression(node, initialScope) {\n        const test = getStaticValueR(node.test, initialScope)\n        if (test != null) {\n            return test.value\n                ? getStaticValueR(node.consequent, initialScope)\n                : getStaticValueR(node.alternate, initialScope)\n        }\n        return null\n    },\n\n    ExpressionStatement(node, initialScope) {\n        return getStaticValueR(node.expression, initialScope)\n    },\n\n    Identifier(node, initialScope) {\n        if (initialScope != null) {\n            const variable = findVariable(initialScope, node)\n\n            // Built-in globals.\n            if (\n                variable != null &&\n                variable.defs.length === 0 &&\n                builtinNames.has(variable.name) &&\n                variable.name in globalObject\n            ) {\n                return { value: globalObject[variable.name] }\n            }\n\n            // Constants.\n            if (variable != null && variable.defs.length === 1) {\n                const def = variable.defs[0]\n                if (\n                    def.parent &&\n                    def.type === \"Variable\" &&\n                    (def.parent.kind === \"const\" ||\n                        isEffectivelyConst(variable)) &&\n                    // TODO(mysticatea): don't support destructuring here.\n                    def.node.id.type === \"Identifier\"\n                ) {\n                    return getStaticValueR(def.node.init, initialScope)\n                }\n            }\n        }\n        return null\n    },\n\n    Literal(node) {\n        //istanbul ignore if : this is implementation-specific behavior.\n        if ((node.regex != null || node.bigint != null) && node.value == null) {\n            // It was a RegExp/BigInt literal, but Node.js didn't support it.\n            return null\n        }\n        return { value: node.value }\n    },\n\n    LogicalExpression(node, initialScope) {\n        const left = getStaticValueR(node.left, initialScope)\n        if (left != null) {\n            if (\n                (node.operator === \"||\" && Boolean(left.value) === true) ||\n                (node.operator === \"&&\" && Boolean(left.value) === false) ||\n                (node.operator === \"??\" && left.value != null)\n            ) {\n                return left\n            }\n\n            const right = getStaticValueR(node.right, initialScope)\n            if (right != null) {\n                return right\n            }\n        }\n\n        return null\n    },\n\n    MemberExpression(node, initialScope) {\n        if (node.property.type === \"PrivateIdentifier\") {\n            return null\n        }\n        const object = getStaticValueR(node.object, initialScope)\n        if (object != null) {\n            if (object.value == null && (object.optional || node.optional)) {\n                return { value: undefined, optional: true }\n            }\n            const property = getStaticPropertyNameValue(node, initialScope)\n\n            if (property != null) {\n                if (!isGetter(object.value, property.value)) {\n                    return { value: object.value[property.value] }\n                }\n\n                for (const [classFn, allowed] of getterAllowed) {\n                    if (\n                        object.value instanceof classFn &&\n                        allowed.has(property.value)\n                    ) {\n                        return { value: object.value[property.value] }\n                    }\n                }\n            }\n        }\n        return null\n    },\n\n    ChainExpression(node, initialScope) {\n        const expression = getStaticValueR(node.expression, initialScope)\n        if (expression != null) {\n            return { value: expression.value }\n        }\n        return null\n    },\n\n    NewExpression(node, initialScope) {\n        const callee = getStaticValueR(node.callee, initialScope)\n        const args = getElementValues(node.arguments, initialScope)\n\n        if (callee != null && args != null) {\n            const Func = callee.value\n            if (callAllowed.has(Func)) {\n                return { value: new Func(...args) }\n            }\n        }\n\n        return null\n    },\n\n    ObjectExpression(node, initialScope) {\n        const object = {}\n\n        for (const propertyNode of node.properties) {\n            if (propertyNode.type === \"Property\") {\n                if (propertyNode.kind !== \"init\") {\n                    return null\n                }\n                const key = getStaticPropertyNameValue(\n                    propertyNode,\n                    initialScope,\n                )\n                const value = getStaticValueR(propertyNode.value, initialScope)\n                if (key == null || value == null) {\n                    return null\n                }\n                object[key.value] = value.value\n            } else if (\n                propertyNode.type === \"SpreadElement\" ||\n                propertyNode.type === \"ExperimentalSpreadProperty\"\n            ) {\n                const argument = getStaticValueR(\n                    propertyNode.argument,\n                    initialScope,\n                )\n                if (argument == null) {\n                    return null\n                }\n                Object.assign(object, argument.value)\n            } else {\n                return null\n            }\n        }\n\n        return { value: object }\n    },\n\n    SequenceExpression(node, initialScope) {\n        const last = node.expressions[node.expressions.length - 1]\n        return getStaticValueR(last, initialScope)\n    },\n\n    TaggedTemplateExpression(node, initialScope) {\n        const tag = getStaticValueR(node.tag, initialScope)\n        const expressions = getElementValues(\n            node.quasi.expressions,\n            initialScope,\n        )\n\n        if (tag != null && expressions != null) {\n            const func = tag.value\n            const strings = node.quasi.quasis.map((q) => q.value.cooked)\n            strings.raw = node.quasi.quasis.map((q) => q.value.raw)\n\n            if (func === String.raw) {\n                return { value: func(strings, ...expressions) }\n            }\n        }\n\n        return null\n    },\n\n    TemplateLiteral(node, initialScope) {\n        const expressions = getElementValues(node.expressions, initialScope)\n        if (expressions != null) {\n            let value = node.quasis[0].value.cooked\n            for (let i = 0; i < expressions.length; ++i) {\n                value += expressions[i]\n                value += node.quasis[i + 1].value.cooked\n            }\n            return { value }\n        }\n        return null\n    },\n\n    UnaryExpression(node, initialScope) {\n        if (node.operator === \"delete\") {\n            // Not supported.\n            return null\n        }\n        if (node.operator === \"void\") {\n            return { value: undefined }\n        }\n\n        const arg = getStaticValueR(node.argument, initialScope)\n        if (arg != null) {\n            switch (node.operator) {\n                case \"-\":\n                    return { value: -arg.value }\n                case \"+\":\n                    return { value: +arg.value } //eslint-disable-line no-implicit-coercion\n                case \"!\":\n                    return { value: !arg.value }\n                case \"~\":\n                    return { value: ~arg.value }\n                case \"typeof\":\n                    return { value: typeof arg.value }\n\n                // no default\n            }\n        }\n\n        return null\n    },\n})\n\n/**\n * Get the value of a given node if it's a static value.\n * @param {Node} node The node to get.\n * @param {Scope|undefined} initialScope The scope to start finding variable.\n * @returns {{value:any}|{value:undefined,optional?:true}|null} The static value of the node, or `null`.\n */\nfunction getStaticValueR(node, initialScope) {\n    if (node != null && Object.hasOwnProperty.call(operations, node.type)) {\n        return operations[node.type](node, initialScope)\n    }\n    return null\n}\n\n/**\n * Get the static value of property name from a MemberExpression node or a Property node.\n * @param {Node} node The node to get.\n * @param {Scope} [initialScope] The scope to start finding variable. Optional. If the node is a computed property node and this scope was given, this checks the computed property name by the `getStringIfConstant` function with the scope, and returns the value of it.\n * @returns {{value:any}|{value:undefined,optional?:true}|null} The static value of the property name of the node, or `null`.\n */\nfunction getStaticPropertyNameValue(node, initialScope) {\n    const nameNode = node.type === \"Property\" ? node.key : node.property\n\n    if (node.computed) {\n        return getStaticValueR(nameNode, initialScope)\n    }\n\n    if (nameNode.type === \"Identifier\") {\n        return { value: nameNode.name }\n    }\n\n    if (nameNode.type === \"Literal\") {\n        if (nameNode.bigint) {\n            return { value: nameNode.bigint }\n        }\n        return { value: String(nameNode.value) }\n    }\n\n    return null\n}\n\n/**\n * Get the value of a given node if it's a static value.\n * @param {Node} node The node to get.\n * @param {Scope} [initialScope] The scope to start finding variable. Optional. If this scope was given, this tries to resolve identifier references which are in the given node as much as possible.\n * @returns {{value:any}|{value:undefined,optional?:true}|null} The static value of the node, or `null`.\n */\nexport function getStaticValue(node, initialScope = null) {\n    try {\n        return getStaticValueR(node, initialScope)\n    } catch (_error) {\n        return null\n    }\n}\n", "import { getStaticValue } from \"./get-static-value.mjs\"\n\n/**\n * Get the value of a given node if it's a literal or a template literal.\n * @param {Node} node The node to get.\n * @param {Scope} [initialScope] The scope to start finding variable. Optional. If the node is an Identifier node and this scope was given, this checks the variable of the identifier, and returns the value of it if the variable is a constant.\n * @returns {string|null} The value of the node, or `null`.\n */\nexport function getStringIfConstant(node, initialScope = null) {\n    // Handle the literals that the platform doesn't support natively.\n    if (node && node.type === \"Literal\" && node.value === null) {\n        if (node.regex) {\n            return `/${node.regex.pattern}/${node.regex.flags}`\n        }\n        if (node.bigint) {\n            return node.bigint\n        }\n    }\n\n    const evaluated = getStaticValue(node, initialScope)\n    return evaluated && String(evaluated.value)\n}\n", "import { getStringIfConstant } from \"./get-string-if-constant.mjs\"\n\n/**\n * Get the property name from a MemberExpression node or a Property node.\n * @param {Node} node The node to get.\n * @param {Scope} [initialScope] The scope to start finding variable. Optional. If the node is a computed property node and this scope was given, this checks the computed property name by the `getStringIfConstant` function with the scope, and returns the value of it.\n * @returns {string|null} The property name of the node.\n */\nexport function getPropertyName(node, initialScope) {\n    switch (node.type) {\n        case \"MemberExpression\":\n            if (node.computed) {\n                return getStringIfConstant(node.property, initialScope)\n            }\n            if (node.property.type === \"PrivateIdentifier\") {\n                return null\n            }\n            return node.property.name\n\n        case \"Property\":\n        case \"MethodDefinition\":\n        case \"PropertyDefinition\":\n            if (node.computed) {\n                return getStringIfConstant(node.key, initialScope)\n            }\n            if (node.key.type === \"Literal\") {\n                return String(node.key.value)\n            }\n            if (node.key.type === \"PrivateIdentifier\") {\n                return null\n            }\n            return node.key.name\n\n        // no default\n    }\n\n    return null\n}\n", "import { getPropertyName } from \"./get-property-name.mjs\"\n\n/**\n * Get the name and kind of the given function node.\n * @param {ASTNode} node - The function node to get.\n * @param {SourceCode} [sourceCode] The source code object to get the code of computed property keys.\n * @returns {string} The name and kind of the function node.\n */\n// eslint-disable-next-line complexity\nexport function getFunctionNameWithKind(node, sourceCode) {\n    const parent = node.parent\n    const tokens = []\n    const isObjectMethod = parent.type === \"Property\" && parent.value === node\n    const isClassMethod =\n        parent.type === \"MethodDefinition\" && parent.value === node\n    const isClassFieldMethod =\n        parent.type === \"PropertyDefinition\" && parent.value === node\n\n    // Modifiers.\n    if (isClassMethod || isClassFieldMethod) {\n        if (parent.static) {\n            tokens.push(\"static\")\n        }\n        if (parent.key.type === \"PrivateIdentifier\") {\n            tokens.push(\"private\")\n        }\n    }\n    if (node.async) {\n        tokens.push(\"async\")\n    }\n    if (node.generator) {\n        tokens.push(\"generator\")\n    }\n\n    // Kinds.\n    if (isObjectMethod || isClassMethod) {\n        if (parent.kind === \"constructor\") {\n            return \"constructor\"\n        }\n        if (parent.kind === \"get\") {\n            tokens.push(\"getter\")\n        } else if (parent.kind === \"set\") {\n            tokens.push(\"setter\")\n        } else {\n            tokens.push(\"method\")\n        }\n    } else if (isClassFieldMethod) {\n        tokens.push(\"method\")\n    } else {\n        if (node.type === \"ArrowFunctionExpression\") {\n            tokens.push(\"arrow\")\n        }\n        tokens.push(\"function\")\n    }\n\n    // Names.\n    if (isObjectMethod || isClassMethod || isClassFieldMethod) {\n        if (parent.key.type === \"PrivateIdentifier\") {\n            tokens.push(`#${parent.key.name}`)\n        } else {\n            const name = getPropertyName(parent)\n            if (name) {\n                tokens.push(`'${name}'`)\n            } else if (sourceCode) {\n                const keyText = sourceCode.getText(parent.key)\n                if (!keyText.includes(\"\\n\")) {\n                    tokens.push(`[${keyText}]`)\n                }\n            }\n        }\n    } else if (node.id) {\n        tokens.push(`'${node.id.name}'`)\n    } else if (\n        parent.type === \"VariableDeclarator\" &&\n        parent.id &&\n        parent.id.type === \"Identifier\"\n    ) {\n        tokens.push(`'${parent.id.name}'`)\n    } else if (\n        (parent.type === \"AssignmentExpression\" ||\n            parent.type === \"AssignmentPattern\") &&\n        parent.left &&\n        parent.left.type === \"Identifier\"\n    ) {\n        tokens.push(`'${parent.left.name}'`)\n    } else if (\n        parent.type === \"ExportDefaultDeclaration\" &&\n        parent.declaration === node\n    ) {\n        tokens.push(\"'default'\")\n    }\n\n    return tokens.join(\" \")\n}\n", "import { getKeys, KEYS } from \"eslint-visitor-keys\"\n\nconst typeConversionBinaryOps = Object.freeze(\n    new Set([\n        \"==\",\n        \"!=\",\n        \"<\",\n        \"<=\",\n        \">\",\n        \">=\",\n        \"<<\",\n        \">>\",\n        \">>>\",\n        \"+\",\n        \"-\",\n        \"*\",\n        \"/\",\n        \"%\",\n        \"|\",\n        \"^\",\n        \"&\",\n        \"in\",\n    ]),\n)\nconst typeConversionUnaryOps = Object.freeze(new Set([\"-\", \"+\", \"!\", \"~\"]))\n\n/**\n * Check whether the given value is an ASTNode or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an ASTNode.\n */\nfunction isNode(x) {\n    return x !== null && typeof x === \"object\" && typeof x.type === \"string\"\n}\n\nconst visitor = Object.freeze(\n    Object.assign(Object.create(null), {\n        $visit(node, options, visitorKeys) {\n            const { type } = node\n\n            if (typeof this[type] === \"function\") {\n                return this[type](node, options, visitorKeys)\n            }\n\n            return this.$visitChildren(node, options, visitorKeys)\n        },\n\n        $visitChildren(node, options, visitorKeys) {\n            const { type } = node\n\n            for (const key of visitorKeys[type] || getKeys(node)) {\n                const value = node[key]\n\n                if (Array.isArray(value)) {\n                    for (const element of value) {\n                        if (\n                            isNode(element) &&\n                            this.$visit(element, options, visitorKeys)\n                        ) {\n                            return true\n                        }\n                    }\n                } else if (\n                    isNode(value) &&\n                    this.$visit(value, options, visitorKeys)\n                ) {\n                    return true\n                }\n            }\n\n            return false\n        },\n\n        ArrowFunctionExpression() {\n            return false\n        },\n        AssignmentExpression() {\n            return true\n        },\n        AwaitExpression() {\n            return true\n        },\n        BinaryExpression(node, options, visitorKeys) {\n            if (\n                options.considerImplicitTypeConversion &&\n                typeConversionBinaryOps.has(node.operator) &&\n                (node.left.type !== \"Literal\" || node.right.type !== \"Literal\")\n            ) {\n                return true\n            }\n            return this.$visitChildren(node, options, visitorKeys)\n        },\n        CallExpression() {\n            return true\n        },\n        FunctionExpression() {\n            return false\n        },\n        ImportExpression() {\n            return true\n        },\n        MemberExpression(node, options, visitorKeys) {\n            if (options.considerGetters) {\n                return true\n            }\n            if (\n                options.considerImplicitTypeConversion &&\n                node.computed &&\n                node.property.type !== \"Literal\"\n            ) {\n                return true\n            }\n            return this.$visitChildren(node, options, visitorKeys)\n        },\n        MethodDefinition(node, options, visitorKeys) {\n            if (\n                options.considerImplicitTypeConversion &&\n                node.computed &&\n                node.key.type !== \"Literal\"\n            ) {\n                return true\n            }\n            return this.$visitChildren(node, options, visitorKeys)\n        },\n        NewExpression() {\n            return true\n        },\n        Property(node, options, visitorKeys) {\n            if (\n                options.considerImplicitTypeConversion &&\n                node.computed &&\n                node.key.type !== \"Literal\"\n            ) {\n                return true\n            }\n            return this.$visitChildren(node, options, visitorKeys)\n        },\n        PropertyDefinition(node, options, visitorKeys) {\n            if (\n                options.considerImplicitTypeConversion &&\n                node.computed &&\n                node.key.type !== \"Literal\"\n            ) {\n                return true\n            }\n            return this.$visitChildren(node, options, visitorKeys)\n        },\n        UnaryExpression(node, options, visitorKeys) {\n            if (node.operator === \"delete\") {\n                return true\n            }\n            if (\n                options.considerImplicitTypeConversion &&\n                typeConversionUnaryOps.has(node.operator) &&\n                node.argument.type !== \"Literal\"\n            ) {\n                return true\n            }\n            return this.$visitChildren(node, options, visitorKeys)\n        },\n        UpdateExpression() {\n            return true\n        },\n        YieldExpression() {\n            return true\n        },\n    }),\n)\n\n/**\n * Check whether a given node has any side effect or not.\n * @param {Node} node The node to get.\n * @param {SourceCode} sourceCode The source code object.\n * @param {object} [options] The option object.\n * @param {boolean} [options.considerGetters=false] If `true` then it considers member accesses as the node which has side effects.\n * @param {boolean} [options.considerImplicitTypeConversion=false] If `true` then it considers implicit type conversion as the node which has side effects.\n * @param {object} [options.visitorKeys=KEYS] The keys to traverse nodes. Use `context.getSourceCode().visitorKeys`.\n * @returns {boolean} `true` if the node has a certain side effect.\n */\nexport function hasSideEffect(\n    node,\n    sourceCode,\n    { considerGetters = false, considerImplicitTypeConversion = false } = {},\n) {\n    return visitor.$visit(\n        node,\n        { considerGetters, considerImplicitTypeConversion },\n        sourceCode.visitorKeys || KEYS,\n    )\n}\n", "import { isClosingParenToken, isOpeningParenToken } from \"./token-predicate.mjs\"\n\n/**\n * Get the left parenthesis of the parent node syntax if it exists.\n * E.g., `if (a) {}` then the `(`.\n * @param {Node} node The AST node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token|null} The left parenthesis of the parent node syntax\n */\nfunction getParentSyntaxParen(node, sourceCode) {\n    const parent = node.parent\n\n    switch (parent.type) {\n        case \"CallExpression\":\n        case \"NewExpression\":\n            if (parent.arguments.length === 1 && parent.arguments[0] === node) {\n                return sourceCode.getTokenAfter(\n                    parent.callee,\n                    isOpeningParenToken,\n                )\n            }\n            return null\n\n        case \"DoWhileStatement\":\n            if (parent.test === node) {\n                return sourceCode.getTokenAfter(\n                    parent.body,\n                    isOpeningParenToken,\n                )\n            }\n            return null\n\n        case \"IfStatement\":\n        case \"WhileStatement\":\n            if (parent.test === node) {\n                return sourceCode.getFirstToken(parent, 1)\n            }\n            return null\n\n        case \"ImportExpression\":\n            if (parent.source === node) {\n                return sourceCode.getFirstToken(parent, 1)\n            }\n            return null\n\n        case \"SwitchStatement\":\n            if (parent.discriminant === node) {\n                return sourceCode.getFirstToken(parent, 1)\n            }\n            return null\n\n        case \"WithStatement\":\n            if (parent.object === node) {\n                return sourceCode.getFirstToken(parent, 1)\n            }\n            return null\n\n        default:\n            return null\n    }\n}\n\n/**\n * Check whether a given node is parenthesized or not.\n * @param {number} times The number of parantheses.\n * @param {Node} node The AST node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is parenthesized the given times.\n */\n/**\n * Check whether a given node is parenthesized or not.\n * @param {Node} node The AST node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is parenthesized.\n */\nexport function isParenthesized(\n    timesOrNode,\n    nodeOrSourceCode,\n    optionalSourceCode,\n) {\n    let times, node, sourceCode, maybeLeftParen, maybeRightParen\n    if (typeof timesOrNode === \"number\") {\n        times = timesOrNode | 0\n        node = nodeOrSourceCode\n        sourceCode = optionalSourceCode\n        if (!(times >= 1)) {\n            throw new TypeError(\"'times' should be a positive integer.\")\n        }\n    } else {\n        times = 1\n        node = timesOrNode\n        sourceCode = nodeOrSourceCode\n    }\n\n    if (\n        node == null ||\n        // `Program` can't be parenthesized\n        node.parent == null ||\n        // `CatchClause.param` can't be parenthesized, example `try {} catch (error) {}`\n        (node.parent.type === \"CatchClause\" && node.parent.param === node)\n    ) {\n        return false\n    }\n\n    maybeLeftParen = maybeRightParen = node\n    do {\n        maybeLeftParen = sourceCode.getTokenBefore(maybeLeftParen)\n        maybeRightParen = sourceCode.getTokenAfter(maybeRightParen)\n    } while (\n        maybeLeftParen != null &&\n        maybeRightParen != null &&\n        isOpeningParenToken(maybeLeftParen) &&\n        isClosingParenToken(maybeRightParen) &&\n        // Avoid false positive such as `if (a) {}`\n        maybeLeftParen !== getParentSyntaxParen(node, sourceCode) &&\n        --times > 0\n    )\n\n    return times === 0\n}\n", "/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * See LICENSE file in root directory for full license.\n */\n\nconst placeholder = /\\$(?:[$&`']|[1-9][0-9]?)/gu\n\n/** @type {WeakMap<PatternMatcher, {pattern:RegExp,escaped:boolean}>} */\nconst internal = new WeakMap()\n\n/**\n * Check whether a given character is escaped or not.\n * @param {string} str The string to check.\n * @param {number} index The location of the character to check.\n * @returns {boolean} `true` if the character is escaped.\n */\nfunction isEscaped(str, index) {\n    let escaped = false\n    for (let i = index - 1; i >= 0 && str.charCodeAt(i) === 0x5c; --i) {\n        escaped = !escaped\n    }\n    return escaped\n}\n\n/**\n * Replace a given string by a given matcher.\n * @param {PatternMatcher} matcher The pattern matcher.\n * @param {string} str The string to be replaced.\n * @param {string} replacement The new substring to replace each matched part.\n * @returns {string} The replaced string.\n */\nfunction replaceS(matcher, str, replacement) {\n    const chunks = []\n    let index = 0\n\n    /** @type {RegExpExecArray} */\n    let match = null\n\n    /**\n     * @param {string} key The placeholder.\n     * @returns {string} The replaced string.\n     */\n    function replacer(key) {\n        switch (key) {\n            case \"$$\":\n                return \"$\"\n            case \"$&\":\n                return match[0]\n            case \"$`\":\n                return str.slice(0, match.index)\n            case \"$'\":\n                return str.slice(match.index + match[0].length)\n            default: {\n                const i = key.slice(1)\n                if (i in match) {\n                    return match[i]\n                }\n                return key\n            }\n        }\n    }\n\n    for (match of matcher.execAll(str)) {\n        chunks.push(str.slice(index, match.index))\n        chunks.push(replacement.replace(placeholder, replacer))\n        index = match.index + match[0].length\n    }\n    chunks.push(str.slice(index))\n\n    return chunks.join(\"\")\n}\n\n/**\n * Replace a given string by a given matcher.\n * @param {PatternMatcher} matcher The pattern matcher.\n * @param {string} str The string to be replaced.\n * @param {(...strs[])=>string} replace The function to replace each matched part.\n * @returns {string} The replaced string.\n */\nfunction replaceF(matcher, str, replace) {\n    const chunks = []\n    let index = 0\n\n    for (const match of matcher.execAll(str)) {\n        chunks.push(str.slice(index, match.index))\n        chunks.push(String(replace(...match, match.index, match.input)))\n        index = match.index + match[0].length\n    }\n    chunks.push(str.slice(index))\n\n    return chunks.join(\"\")\n}\n\n/**\n * The class to find patterns as considering escape sequences.\n */\nexport class PatternMatcher {\n    /**\n     * Initialize this matcher.\n     * @param {RegExp} pattern The pattern to match.\n     * @param {{escaped:boolean}} options The options.\n     */\n    constructor(pattern, { escaped = false } = {}) {\n        if (!(pattern instanceof RegExp)) {\n            throw new TypeError(\"'pattern' should be a RegExp instance.\")\n        }\n        if (!pattern.flags.includes(\"g\")) {\n            throw new Error(\"'pattern' should contains 'g' flag.\")\n        }\n\n        internal.set(this, {\n            pattern: new RegExp(pattern.source, pattern.flags),\n            escaped: Boolean(escaped),\n        })\n    }\n\n    /**\n     * Find the pattern in a given string.\n     * @param {string} str The string to find.\n     * @returns {IterableIterator<RegExpExecArray>} The iterator which iterate the matched information.\n     */\n    *execAll(str) {\n        const { pattern, escaped } = internal.get(this)\n        let match = null\n        let lastIndex = 0\n\n        pattern.lastIndex = 0\n        while ((match = pattern.exec(str)) != null) {\n            if (escaped || !isEscaped(str, match.index)) {\n                lastIndex = pattern.lastIndex\n                yield match\n                pattern.lastIndex = lastIndex\n            }\n        }\n    }\n\n    /**\n     * Check whether the pattern is found in a given string.\n     * @param {string} str The string to check.\n     * @returns {boolean} `true` if the pattern was found in the string.\n     */\n    test(str) {\n        const it = this.execAll(str)\n        const ret = it.next()\n        return !ret.done\n    }\n\n    /**\n     * Replace a given string.\n     * @param {string} str The string to be replaced.\n     * @param {(string|((...strs:string[])=>string))} replacer The string or function to replace. This is the same as the 2nd argument of `String.prototype.replace`.\n     * @returns {string} The replaced string.\n     */\n    [Symbol.replace](str, replacer) {\n        return typeof replacer === \"function\"\n            ? replaceF(this, String(str), replacer)\n            : replaceS(this, String(str), String(replacer))\n    }\n}\n", "import { findVariable } from \"./find-variable.mjs\"\nimport { getPropertyName } from \"./get-property-name.mjs\"\nimport { getStringIfConstant } from \"./get-string-if-constant.mjs\"\n\nconst IMPORT_TYPE = /^(?:Import|Export(?:All|Default|Named))Declaration$/u\nconst has = Function.call.bind(Object.hasOwnProperty)\n\nexport const READ = Symbol(\"read\")\nexport const CALL = Symbol(\"call\")\nexport const CONSTRUCT = Symbol(\"construct\")\nexport const ESM = Symbol(\"esm\")\n\nconst requireCall = { require: { [CALL]: true } }\n\n/**\n * Check whether a given variable is modified or not.\n * @param {Variable} variable The variable to check.\n * @returns {boolean} `true` if the variable is modified.\n */\nfunction isModifiedGlobal(variable) {\n    return (\n        variable == null ||\n        variable.defs.length !== 0 ||\n        variable.references.some((r) => r.isWrite())\n    )\n}\n\n/**\n * Check if the value of a given node is passed through to the parent syntax as-is.\n * For example, `a` and `b` in (`a || b` and `c ? a : b`) are passed through.\n * @param {Node} node A node to check.\n * @returns {boolean} `true` if the node is passed through.\n */\nfunction isPassThrough(node) {\n    const parent = node.parent\n\n    switch (parent && parent.type) {\n        case \"ConditionalExpression\":\n            return parent.consequent === node || parent.alternate === node\n        case \"LogicalExpression\":\n            return true\n        case \"SequenceExpression\":\n            return parent.expressions[parent.expressions.length - 1] === node\n        case \"ChainExpression\":\n            return true\n\n        default:\n            return false\n    }\n}\n\n/**\n * The reference tracker.\n */\nexport class ReferenceTracker {\n    /**\n     * Initialize this tracker.\n     * @param {Scope} globalScope The global scope.\n     * @param {object} [options] The options.\n     * @param {\"legacy\"|\"strict\"} [options.mode=\"strict\"] The mode to determine the ImportDeclaration's behavior for CJS modules.\n     * @param {string[]} [options.globalObjectNames=[\"global\",\"globalThis\",\"self\",\"window\"]] The variable names for Global Object.\n     */\n    constructor(\n        globalScope,\n        {\n            mode = \"strict\",\n            globalObjectNames = [\"global\", \"globalThis\", \"self\", \"window\"],\n        } = {},\n    ) {\n        this.variableStack = []\n        this.globalScope = globalScope\n        this.mode = mode\n        this.globalObjectNames = globalObjectNames.slice(0)\n    }\n\n    /**\n     * Iterate the references of global variables.\n     * @param {object} traceMap The trace map.\n     * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.\n     */\n    *iterateGlobalReferences(traceMap) {\n        for (const key of Object.keys(traceMap)) {\n            const nextTraceMap = traceMap[key]\n            const path = [key]\n            const variable = this.globalScope.set.get(key)\n\n            if (isModifiedGlobal(variable)) {\n                continue\n            }\n\n            yield* this._iterateVariableReferences(\n                variable,\n                path,\n                nextTraceMap,\n                true,\n            )\n        }\n\n        for (const key of this.globalObjectNames) {\n            const path = []\n            const variable = this.globalScope.set.get(key)\n\n            if (isModifiedGlobal(variable)) {\n                continue\n            }\n\n            yield* this._iterateVariableReferences(\n                variable,\n                path,\n                traceMap,\n                false,\n            )\n        }\n    }\n\n    /**\n     * Iterate the references of CommonJS modules.\n     * @param {object} traceMap The trace map.\n     * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.\n     */\n    *iterateCjsReferences(traceMap) {\n        for (const { node } of this.iterateGlobalReferences(requireCall)) {\n            const key = getStringIfConstant(node.arguments[0])\n            if (key == null || !has(traceMap, key)) {\n                continue\n            }\n\n            const nextTraceMap = traceMap[key]\n            const path = [key]\n\n            if (nextTraceMap[READ]) {\n                yield {\n                    node,\n                    path,\n                    type: READ,\n                    info: nextTraceMap[READ],\n                }\n            }\n            yield* this._iteratePropertyReferences(node, path, nextTraceMap)\n        }\n    }\n\n    /**\n     * Iterate the references of ES modules.\n     * @param {object} traceMap The trace map.\n     * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.\n     */\n    *iterateEsmReferences(traceMap) {\n        const programNode = this.globalScope.block\n\n        for (const node of programNode.body) {\n            if (!IMPORT_TYPE.test(node.type) || node.source == null) {\n                continue\n            }\n            const moduleId = node.source.value\n\n            if (!has(traceMap, moduleId)) {\n                continue\n            }\n            const nextTraceMap = traceMap[moduleId]\n            const path = [moduleId]\n\n            if (nextTraceMap[READ]) {\n                yield { node, path, type: READ, info: nextTraceMap[READ] }\n            }\n\n            if (node.type === \"ExportAllDeclaration\") {\n                for (const key of Object.keys(nextTraceMap)) {\n                    const exportTraceMap = nextTraceMap[key]\n                    if (exportTraceMap[READ]) {\n                        yield {\n                            node,\n                            path: path.concat(key),\n                            type: READ,\n                            info: exportTraceMap[READ],\n                        }\n                    }\n                }\n            } else {\n                for (const specifier of node.specifiers) {\n                    const esm = has(nextTraceMap, ESM)\n                    const it = this._iterateImportReferences(\n                        specifier,\n                        path,\n                        esm\n                            ? nextTraceMap\n                            : this.mode === \"legacy\"\n                            ? { default: nextTraceMap, ...nextTraceMap }\n                            : { default: nextTraceMap },\n                    )\n\n                    if (esm) {\n                        yield* it\n                    } else {\n                        for (const report of it) {\n                            report.path = report.path.filter(exceptDefault)\n                            if (\n                                report.path.length >= 2 ||\n                                report.type !== READ\n                            ) {\n                                yield report\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Iterate the references for a given variable.\n     * @param {Variable} variable The variable to iterate that references.\n     * @param {string[]} path The current path.\n     * @param {object} traceMap The trace map.\n     * @param {boolean} shouldReport = The flag to report those references.\n     * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.\n     */\n    *_iterateVariableReferences(variable, path, traceMap, shouldReport) {\n        if (this.variableStack.includes(variable)) {\n            return\n        }\n        this.variableStack.push(variable)\n        try {\n            for (const reference of variable.references) {\n                if (!reference.isRead()) {\n                    continue\n                }\n                const node = reference.identifier\n\n                if (shouldReport && traceMap[READ]) {\n                    yield { node, path, type: READ, info: traceMap[READ] }\n                }\n                yield* this._iteratePropertyReferences(node, path, traceMap)\n            }\n        } finally {\n            this.variableStack.pop()\n        }\n    }\n\n    /**\n     * Iterate the references for a given AST node.\n     * @param rootNode The AST node to iterate references.\n     * @param {string[]} path The current path.\n     * @param {object} traceMap The trace map.\n     * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.\n     */\n    //eslint-disable-next-line complexity\n    *_iteratePropertyReferences(rootNode, path, traceMap) {\n        let node = rootNode\n        while (isPassThrough(node)) {\n            node = node.parent\n        }\n\n        const parent = node.parent\n        if (parent.type === \"MemberExpression\") {\n            if (parent.object === node) {\n                const key = getPropertyName(parent)\n                if (key == null || !has(traceMap, key)) {\n                    return\n                }\n\n                path = path.concat(key) //eslint-disable-line no-param-reassign\n                const nextTraceMap = traceMap[key]\n                if (nextTraceMap[READ]) {\n                    yield {\n                        node: parent,\n                        path,\n                        type: READ,\n                        info: nextTraceMap[READ],\n                    }\n                }\n                yield* this._iteratePropertyReferences(\n                    parent,\n                    path,\n                    nextTraceMap,\n                )\n            }\n            return\n        }\n        if (parent.type === \"CallExpression\") {\n            if (parent.callee === node && traceMap[CALL]) {\n                yield { node: parent, path, type: CALL, info: traceMap[CALL] }\n            }\n            return\n        }\n        if (parent.type === \"NewExpression\") {\n            if (parent.callee === node && traceMap[CONSTRUCT]) {\n                yield {\n                    node: parent,\n                    path,\n                    type: CONSTRUCT,\n                    info: traceMap[CONSTRUCT],\n                }\n            }\n            return\n        }\n        if (parent.type === \"AssignmentExpression\") {\n            if (parent.right === node) {\n                yield* this._iterateLhsReferences(parent.left, path, traceMap)\n                yield* this._iteratePropertyReferences(parent, path, traceMap)\n            }\n            return\n        }\n        if (parent.type === \"AssignmentPattern\") {\n            if (parent.right === node) {\n                yield* this._iterateLhsReferences(parent.left, path, traceMap)\n            }\n            return\n        }\n        if (parent.type === \"VariableDeclarator\") {\n            if (parent.init === node) {\n                yield* this._iterateLhsReferences(parent.id, path, traceMap)\n            }\n        }\n    }\n\n    /**\n     * Iterate the references for a given Pattern node.\n     * @param {Node} patternNode The Pattern node to iterate references.\n     * @param {string[]} path The current path.\n     * @param {object} traceMap The trace map.\n     * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.\n     */\n    *_iterateLhsReferences(patternNode, path, traceMap) {\n        if (patternNode.type === \"Identifier\") {\n            const variable = findVariable(this.globalScope, patternNode)\n            if (variable != null) {\n                yield* this._iterateVariableReferences(\n                    variable,\n                    path,\n                    traceMap,\n                    false,\n                )\n            }\n            return\n        }\n        if (patternNode.type === \"ObjectPattern\") {\n            for (const property of patternNode.properties) {\n                const key = getPropertyName(property)\n\n                if (key == null || !has(traceMap, key)) {\n                    continue\n                }\n\n                const nextPath = path.concat(key)\n                const nextTraceMap = traceMap[key]\n                if (nextTraceMap[READ]) {\n                    yield {\n                        node: property,\n                        path: nextPath,\n                        type: READ,\n                        info: nextTraceMap[READ],\n                    }\n                }\n                yield* this._iterateLhsReferences(\n                    property.value,\n                    nextPath,\n                    nextTraceMap,\n                )\n            }\n            return\n        }\n        if (patternNode.type === \"AssignmentPattern\") {\n            yield* this._iterateLhsReferences(patternNode.left, path, traceMap)\n        }\n    }\n\n    /**\n     * Iterate the references for a given ModuleSpecifier node.\n     * @param {Node} specifierNode The ModuleSpecifier node to iterate references.\n     * @param {string[]} path The current path.\n     * @param {object} traceMap The trace map.\n     * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.\n     */\n    *_iterateImportReferences(specifierNode, path, traceMap) {\n        const type = specifierNode.type\n\n        if (type === \"ImportSpecifier\" || type === \"ImportDefaultSpecifier\") {\n            const key =\n                type === \"ImportDefaultSpecifier\"\n                    ? \"default\"\n                    : specifierNode.imported.name\n            if (!has(traceMap, key)) {\n                return\n            }\n\n            path = path.concat(key) //eslint-disable-line no-param-reassign\n            const nextTraceMap = traceMap[key]\n            if (nextTraceMap[READ]) {\n                yield {\n                    node: specifierNode,\n                    path,\n                    type: READ,\n                    info: nextTraceMap[READ],\n                }\n            }\n            yield* this._iterateVariableReferences(\n                findVariable(this.globalScope, specifierNode.local),\n                path,\n                nextTraceMap,\n                false,\n            )\n\n            return\n        }\n\n        if (type === \"ImportNamespaceSpecifier\") {\n            yield* this._iterateVariableReferences(\n                findVariable(this.globalScope, specifierNode.local),\n                path,\n                traceMap,\n                false,\n            )\n            return\n        }\n\n        if (type === \"ExportSpecifier\") {\n            const key = specifierNode.local.name\n            if (!has(traceMap, key)) {\n                return\n            }\n\n            path = path.concat(key) //eslint-disable-line no-param-reassign\n            const nextTraceMap = traceMap[key]\n            if (nextTraceMap[READ]) {\n                yield {\n                    node: specifierNode,\n                    path,\n                    type: READ,\n                    info: nextTraceMap[READ],\n                }\n            }\n        }\n    }\n}\n\nReferenceTracker.READ = READ\nReferenceTracker.CALL = CALL\nReferenceTracker.CONSTRUCT = CONSTRUCT\nReferenceTracker.ESM = ESM\n\n/**\n * This is a predicate function for Array#filter.\n * @param {string} name A name part.\n * @param {number} index The index of the name.\n * @returns {boolean} `false` if it's default.\n */\nfunction exceptDefault(name, index) {\n    return !(index === 1 && name === \"default\")\n}\n", "import { findVariable } from \"./find-variable.mjs\"\nimport { getFunctionHeadLocation } from \"./get-function-head-location.mjs\"\nimport { getFunctionNameWithKind } from \"./get-function-name-with-kind.mjs\"\nimport { getInnermostScope } from \"./get-innermost-scope.mjs\"\nimport { getPropertyName } from \"./get-property-name.mjs\"\nimport { getStaticValue } from \"./get-static-value.mjs\"\nimport { getStringIfConstant } from \"./get-string-if-constant.mjs\"\nimport { hasSideEffect } from \"./has-side-effect.mjs\"\nimport { isParenthesized } from \"./is-parenthesized.mjs\"\nimport { PatternMatcher } from \"./pattern-matcher.mjs\"\nimport {\n    CALL,\n    CONSTRUCT,\n    ESM,\n    READ,\n    ReferenceTracker,\n} from \"./reference-tracker.mjs\"\nimport {\n    isArrowToken,\n    isClosingBraceToken,\n    isClosingBracketToken,\n    isClosingParenToken,\n    isColonToken,\n    isCommaToken,\n    isCommentToken,\n    isNotArrowToken,\n    isNotClosingBraceToken,\n    isNotClosingBracketToken,\n    isNotClosingParenToken,\n    isNotColonToken,\n    isNotCommaToken,\n    isNotCommentToken,\n    isNotOpeningBraceToken,\n    isNotOpeningBracketToken,\n    isNotOpeningParenToken,\n    isNotSemicolonToken,\n    isOpeningBraceToken,\n    isOpeningBracketToken,\n    isOpeningParenToken,\n    isSemicolonToken,\n} from \"./token-predicate.mjs\"\n\nexport default {\n    CALL,\n    CONSTRUCT,\n    ESM,\n    findVariable,\n    getFunctionHeadLocation,\n    getFunctionNameWithKind,\n    getInnermostScope,\n    getPropertyName,\n    getStaticValue,\n    getStringIfConstant,\n    hasSideEffect,\n    isArrowToken,\n    isClosingBraceToken,\n    isClosingBracketToken,\n    isClosingParenToken,\n    isColonToken,\n    isCommaToken,\n    isCommentToken,\n    isNotArrowToken,\n    isNotClosingBraceToken,\n    isNotClosingBracketToken,\n    isNotClosingParenToken,\n    isNotColonToken,\n    isNotCommaToken,\n    isNotCommentToken,\n    isNotOpeningBraceToken,\n    isNotOpeningBracketToken,\n    isNotOpeningParenToken,\n    isNotSemicolonToken,\n    isOpeningBraceToken,\n    isOpeningBracketToken,\n    isOpeningParenToken,\n    isParenthesized,\n    isSemicolonToken,\n    PatternMatcher,\n    READ,\n    ReferenceTracker,\n}\nexport {\n    CALL,\n    CONSTRUCT,\n    ESM,\n    findVariable,\n    getFunctionHeadLocation,\n    getFunctionNameWithKind,\n    getInnermostScope,\n    getPropertyName,\n    getStaticValue,\n    getStringIfConstant,\n    hasSideEffect,\n    isArrowToken,\n    isClosingBraceToken,\n    isClosingBracketToken,\n    isClosingParenToken,\n    isColonToken,\n    isCommaToken,\n    isCommentToken,\n    isNotArrowToken,\n    isNotClosingBraceToken,\n    isNotClosingBracketToken,\n    isNotClosingParenToken,\n    isNotColonToken,\n    isNotCommaToken,\n    isNotCommentToken,\n    isNotOpeningBraceToken,\n    isNotOpeningBracketToken,\n    isNotOpeningParenToken,\n    isNotSemicolonToken,\n    isOpeningBraceToken,\n    isOpeningBracketToken,\n    isOpeningParenToken,\n    isParenthesized,\n    isSemicolonToken,\n    PatternMatcher,\n    READ,\n    ReferenceTracker,\n}\n", "/**\n * @typedef {typeof import(\"typescript\")} TypeScript\n * @typedef {import(\"typescript\").Type} Type\n * @typedef {import(\"typescript\").ObjectType} ObjectType\n * @typedef {import(\"typescript\").InterfaceType} InterfaceType\n * @typedef {import(\"typescript\").TypeReference} TypeReference\n * @typedef {import(\"typescript\").UnionOrIntersectionType} UnionOrIntersectionType\n * @typedef {import(\"typescript\").TypeParameter} TypeParameter\n */\n\n/** @type {TypeScript | undefined} */\nlet cacheTypeScript\n\nmodule.exports = {\n  getTypeScript,\n  isObject,\n  isAny,\n  isUnknown,\n  isNever,\n  isNull,\n  isFunction,\n  isArrayLikeObject,\n  isStringLike,\n  isNumberLike,\n  isBooleanLike,\n  isBigIntLike,\n  isReferenceObject,\n  extractTypeFlags,\n  extractObjectFlags\n}\n\n/**\n * Get TypeScript instance\n */\nfunction getTypeScript() {\n  if (cacheTypeScript) {\n    return cacheTypeScript\n  }\n  try {\n    return (cacheTypeScript = require('typescript'))\n  } catch (error) {\n    if (/** @type {any} */ (error).code === 'MODULE_NOT_FOUND') {\n      return undefined\n    }\n\n    throw error\n  }\n}\n/**\n * For debug\n * @param {Type} tsType\n * @returns {string[]}\n */\nfunction extractTypeFlags(tsType) {\n  const ts = /** @type {TypeScript} */ (getTypeScript())\n  /** @type {string[]} */\n  const result = []\n  const keys = /** @type {(keyof (typeof ts.TypeFlags))[]} */ (\n    Object.keys(ts.TypeFlags)\n  )\n  for (const k of keys) {\n    if ((tsType.flags & ts.TypeFlags[k]) !== 0) {\n      result.push(k)\n    }\n  }\n  return result\n}\n/**\n * For debug\n * @param {Type} tsType\n * @returns {string[]}\n */\nfunction extractObjectFlags(tsType) {\n  if (!isObject(tsType)) {\n    return []\n  }\n  const ts = /** @type {TypeScript} */ (getTypeScript())\n  /** @type {string[]} */\n  const result = []\n  const keys = /** @type {(keyof (typeof ts.ObjectFlags))[]} */ (\n    Object.keys(ts.ObjectFlags)\n  )\n  for (const k of keys) {\n    if ((tsType.objectFlags & ts.ObjectFlags[k]) !== 0) {\n      result.push(k)\n    }\n  }\n  return result\n}\n\n/**\n * Check if a given type is an object type or not.\n * @param {Type} tsType The type to check.\n * @returns {tsType is ObjectType}\n */\nfunction isObject(tsType) {\n  const ts = /** @type {TypeScript} */ (getTypeScript())\n  return (tsType.flags & ts.TypeFlags.Object) !== 0\n}\n\n/**\n * Check if a given type is an array-like type or not.\n * @param {Type} tsType The type to check.\n */\nfunction isArrayLikeObject(tsType) {\n  const ts = /** @type {TypeScript} */ (getTypeScript())\n  return (\n    isObject(tsType) &&\n    (tsType.objectFlags &\n      (ts.ObjectFlags.ArrayLiteral |\n        ts.ObjectFlags.EvolvingArray |\n        ts.ObjectFlags.Tuple)) !==\n      0\n  )\n}\n/**\n * Check if a given type is an any type or not.\n * @param {Type} tsType The type to check.\n */\nfunction isAny(tsType) {\n  const ts = /** @type {TypeScript} */ (getTypeScript())\n  return (tsType.flags & ts.TypeFlags.Any) !== 0\n}\n/**\n * Check if a given type is an unknown type or not.\n * @param {Type} tsType The type to check.\n */\nfunction isUnknown(tsType) {\n  const ts = /** @type {TypeScript} */ (getTypeScript())\n  return (tsType.flags & ts.TypeFlags.Unknown) !== 0\n}\n/**\n * Check if a given type is a never type or not.\n * @param {Type} tsType The type to check.\n */\nfunction isNever(tsType) {\n  const ts = /** @type {TypeScript} */ (getTypeScript())\n  return (tsType.flags & ts.TypeFlags.Never) !== 0\n}\n/**\n * Check if a given type is an null type or not.\n * @param {Type} tsType The type to check.\n */\nfunction isNull(tsType) {\n  const ts = /** @type {TypeScript} */ (getTypeScript())\n  return (tsType.flags & ts.TypeFlags.Null) !== 0\n}\n\n/**\n * Check if a given type is a string-like type or not.\n * @param {Type} tsType The type to check.\n * @returns {boolean} `true` if the type is a string-like type.\n */\nfunction isStringLike(tsType) {\n  const ts = /** @type {TypeScript} */ (getTypeScript())\n  return (tsType.flags & ts.TypeFlags.StringLike) !== 0\n}\n/**\n * Check if a given type is an number-like type or not.\n * @param {Type} tsType The type to check.\n * @returns {boolean} `true` if the type is a number-like type.\n */\nfunction isNumberLike(tsType) {\n  const ts = /** @type {TypeScript} */ (getTypeScript())\n  return (tsType.flags & ts.TypeFlags.NumberLike) !== 0\n}\n/**\n * Check if a given type is an boolean-like type or not.\n * @param {Type} tsType The type to check.\n * @returns {boolean} `true` if the type is a boolean-like type.\n */\nfunction isBooleanLike(tsType) {\n  const ts = /** @type {TypeScript} */ (getTypeScript())\n  return (tsType.flags & ts.TypeFlags.BooleanLike) !== 0\n}\n/**\n * Check if a given type is an bigint-like type or not.\n * @param {Type} tsType The type to check.\n * @returns {boolean} `true` if the type is a bigint-like type.\n */\nfunction isBigIntLike(tsType) {\n  const ts = /** @type {TypeScript} */ (getTypeScript())\n  return (tsType.flags & ts.TypeFlags.BigIntLike) !== 0\n}\n\n/**\n * Check if a given type is a reference type or not.\n * @param {Type} tsType The type to check.\n * @returns {tsType is TypeReference} `true` if the type is a reference type.\n */\nfunction isReferenceObject(tsType) {\n  const ts = /** @type {TypeScript} */ (getTypeScript())\n  return (\n    isObject(tsType) && (tsType.objectFlags & ts.ObjectFlags.Reference) !== 0\n  )\n}\n/**\n * Check if a given type is `function` or not.\n * @param {Type} tsType The type to check.\n */\nfunction isFunction(tsType) {\n  const ts = /** @type {TypeScript} */ (getTypeScript())\n  if (\n    tsType.symbol &&\n    (tsType.symbol.flags &\n      (ts.SymbolFlags.Function | ts.SymbolFlags.Method)) !==\n      0\n  ) {\n    return true\n  }\n\n  const signatures = tsType.getCallSignatures()\n  return signatures.length > 0\n}\n", "const {\n  getTypeScript,\n  isAny,\n  isUnknown,\n  isNever,\n  isNull,\n  isObject,\n  isFunction,\n  isStringLike,\n  isNumberLike,\n  isBooleanLike,\n  isBigIntLike,\n  isArrayLikeObject,\n  isReferenceObject\n} = require('./typescript')\n/**\n * @typedef {import('@typescript-eslint/types').TSESTree.Node} TSESTreeNode\n * @typedef {import('typescript').Type} Type\n * @typedef {import('typescript').TypeChecker} TypeChecker\n * @typedef {import('typescript').Node} TypeScriptNode\n */\n/**\n * @typedef {import('../index').ComponentInferTypeProp} ComponentInferTypeProp\n * @typedef {import('../index').ComponentUnknownProp} ComponentUnknownProp\n * @typedef {import('../index').ComponentInferTypeEmit} ComponentInferTypeEmit\n * @typedef {import('../index').ComponentUnknownEmit} ComponentUnknownEmit\n */\n\nmodule.exports = {\n  getComponentPropsFromTypeDefineTypes,\n  getComponentEmitsFromTypeDefineTypes,\n  inferRuntimeTypeFromTypeNode\n}\n\n/**\n * @typedef {object} Services\n * @property {typeof import(\"typescript\")} ts\n * @property {Map<ESNode | TSNode | TSESTreeNode, TypeScriptNode>} tsNodeMap\n * @property {import('typescript').TypeChecker} checker\n */\n\n/**\n * Get TypeScript parser services.\n * @param {RuleContext} context The ESLint rule context object.\n * @returns {Services|null}\n */\nfunction getTSParserServices(context) {\n  const sourceCode = context.getSourceCode()\n  const tsNodeMap = sourceCode.parserServices.esTreeNodeToTSNodeMap\n  if (!tsNodeMap) return null\n  const hasFullTypeInformation =\n    sourceCode.parserServices.hasFullTypeInformation !== false\n  const checker =\n    (hasFullTypeInformation &&\n      sourceCode.parserServices.program &&\n      sourceCode.parserServices.program.getTypeChecker()) ||\n    null\n  if (!checker) return null\n  const ts = getTypeScript()\n  if (!ts) return null\n\n  return {\n    ts,\n    tsNodeMap,\n    checker\n  }\n}\n\n/**\n * Get all props by looking at all component's properties\n * @param {RuleContext} context The ESLint rule context object.\n * @param {TypeNode} propsNode Type with props definition\n * @return {(ComponentInferTypeProp|ComponentUnknownProp)[]} Array of component props\n */\nfunction getComponentPropsFromTypeDefineTypes(context, propsNode) {\n  const services = getTSParserServices(context)\n  const tsNode = services && services.tsNodeMap.get(propsNode)\n  const type = tsNode && services.checker.getTypeAtLocation(tsNode)\n  if (\n    !type ||\n    isAny(type) ||\n    isUnknown(type) ||\n    isNever(type) ||\n    isNull(type)\n  ) {\n    return [\n      {\n        type: 'unknown',\n        propName: null,\n        node: propsNode\n      }\n    ]\n  }\n  return [...extractRuntimeProps(type, tsNode, propsNode, services)]\n}\n\n/**\n * Get all emits by looking at all component's properties\n * @param {RuleContext} context The ESLint rule context object.\n * @param {TypeNode} emitsNode Type with emits definition\n * @return {(ComponentInferTypeEmit|ComponentUnknownEmit)[]} Array of component emits\n */\nfunction getComponentEmitsFromTypeDefineTypes(context, emitsNode) {\n  const services = getTSParserServices(context)\n  const tsNode = services && services.tsNodeMap.get(emitsNode)\n  const type = tsNode && services.checker.getTypeAtLocation(tsNode)\n  if (\n    !type ||\n    isAny(type) ||\n    isUnknown(type) ||\n    isNever(type) ||\n    isNull(type)\n  ) {\n    return [\n      {\n        type: 'unknown',\n        emitName: null,\n        node: emitsNode\n      }\n    ]\n  }\n  return [...extractRuntimeEmits(type, tsNode, emitsNode, services)]\n}\n\n/**\n * @param {RuleContext} context The ESLint rule context object.\n * @param {TypeNode|Expression} node\n * @returns {string[]}\n */\nfunction inferRuntimeTypeFromTypeNode(context, node) {\n  const services = getTSParserServices(context)\n  const tsNode = services && services.tsNodeMap.get(node)\n  const type = tsNode && services.checker.getTypeAtLocation(tsNode)\n  if (!type) {\n    return ['null']\n  }\n  return inferRuntimeTypeInternal(type, services)\n}\n\n/**\n * @param {Type} type\n * @param {TypeScriptNode} tsNode\n * @param {TypeNode} propsNode Type with props definition\n * @param {Services} services\n * @returns {IterableIterator<ComponentInferTypeProp>}\n */\nfunction* extractRuntimeProps(type, tsNode, propsNode, services) {\n  const { ts, checker } = services\n  for (const property of type.getProperties()) {\n    const isOptional = (property.flags & ts.SymbolFlags.Optional) !== 0\n    const name = property.getName()\n\n    const type = checker.getTypeOfSymbolAtLocation(property, tsNode)\n\n    yield {\n      type: 'infer-type',\n      propName: name,\n      required: !isOptional,\n      node: propsNode,\n      types: inferRuntimeTypeInternal(type, services)\n    }\n  }\n}\n\n/**\n * @param {Type} type\n * @param {Services} services\n * @returns {string[]}\n */\nfunction inferRuntimeTypeInternal(type, services) {\n  const { checker } = services\n  /** @type {Set<string>} */\n  const types = new Set()\n  for (const targetType of iterateTypes(checker.getNonNullableType(type))) {\n    if (\n      isAny(targetType) ||\n      isUnknown(targetType) ||\n      isNever(targetType) ||\n      isNull(targetType)\n    ) {\n      types.add('null')\n    } else if (isStringLike(targetType)) {\n      types.add('String')\n    } else if (isNumberLike(targetType) || isBigIntLike(targetType)) {\n      types.add('Number')\n    } else if (isBooleanLike(targetType)) {\n      types.add('Boolean')\n    } else if (isFunction(targetType)) {\n      types.add('Function')\n    } else if (\n      isArrayLikeObject(targetType) ||\n      (targetType.isClassOrInterface() &&\n        ['Array', 'ReadonlyArray'].includes(\n          checker.getFullyQualifiedName(targetType.symbol)\n        ))\n    ) {\n      types.add('Array')\n    } else if (isObject(targetType)) {\n      types.add('Object')\n    }\n  }\n\n  if (types.size <= 0) types.add('null')\n\n  return [...types]\n}\n\n/**\n * @param {Type} type\n * @param {TypeScriptNode} tsNode\n * @param {TypeNode} emitsNode Type with emits definition\n * @param {Services} services\n * @returns {IterableIterator<ComponentInferTypeEmit|ComponentUnknownEmit>}\n */\nfunction* extractRuntimeEmits(type, tsNode, emitsNode, services) {\n  const { checker } = services\n  if (isFunction(type)) {\n    for (const signature of type.getCallSignatures()) {\n      const param = signature.getParameters()[0]\n      if (!param) {\n        yield {\n          type: 'unknown',\n          emitName: null,\n          node: emitsNode\n        }\n        continue\n      }\n      const type = checker.getTypeOfSymbolAtLocation(param, tsNode)\n\n      for (const targetType of iterateTypes(type)) {\n        yield targetType.isStringLiteral()\n          ? {\n              type: 'infer-type',\n              emitName: targetType.value,\n              node: emitsNode\n            }\n          : {\n              type: 'unknown',\n              emitName: null,\n              node: emitsNode\n            }\n      }\n    }\n  } else if (isObject(type)) {\n    for (const property of type.getProperties()) {\n      const name = property.getName()\n      yield {\n        type: 'infer-type',\n        emitName: name,\n        node: emitsNode\n      }\n    }\n  } else {\n    yield {\n      type: 'unknown',\n      emitName: null,\n      node: emitsNode\n    }\n  }\n}\n\n/**\n * @param {Type} type\n * @returns {Iterable<Type>}\n */\nfunction* iterateTypes(type) {\n  if (isReferenceObject(type) && type.target !== type) {\n    yield* iterateTypes(type.target)\n  } else if (type.isUnion() && !isBooleanLike(type)) {\n    for (const t of type.types) {\n      yield* iterateTypes(t)\n    }\n  } else {\n    yield type\n  }\n}\n", "const { getScope } = require('../scope')\nconst { findVariable } = require('@eslint-community/eslint-utils')\nconst { inferRuntimeTypeFromTypeNode } = require('./ts-types')\n/**\n * @typedef {import('@typescript-eslint/types').TSESTree.TypeNode} TSESTreeTypeNode\n * @typedef {import('@typescript-eslint/types').TSESTree.TSInterfaceBody} TSESTreeTSInterfaceBody\n * @typedef {import('@typescript-eslint/types').TSESTree.TSTypeLiteral} TSESTreeTSTypeLiteral\n * @typedef {import('@typescript-eslint/types').TSESTree.TSFunctionType} TSESTreeTSFunctionType\n * @typedef {import('@typescript-eslint/types').TSESTree.Parameter} TSESTreeParameter\n * @typedef {import('@typescript-eslint/types').TSESTree.Node} TSESTreeNode\n *\n */\n/**\n * @typedef {import('../index').ComponentTypeProp} ComponentTypeProp\n * @typedef {import('../index').ComponentUnknownProp} ComponentUnknownProp\n * @typedef {import('../index').ComponentTypeEmit} ComponentTypeEmit\n * @typedef {import('../index').ComponentUnknownEmit} ComponentUnknownEmit\n */\n\nconst noop = Function.prototype\n\nmodule.exports = {\n  isTypeNode,\n  flattenTypeNodes,\n  isTSInterfaceBody,\n  isTSTypeLiteral,\n  isTSTypeLiteralOrTSFunctionType,\n  extractRuntimeProps,\n  extractRuntimeEmits\n}\n\n/**\n * @param {ASTNode} node\n * @returns {node is TypeNode}\n */\nfunction isTypeNode(node) {\n  if (\n    node.type === 'TSAbstractKeyword' ||\n    node.type === 'TSAnyKeyword' ||\n    node.type === 'TSAsyncKeyword' ||\n    node.type === 'TSArrayType' ||\n    node.type === 'TSBigIntKeyword' ||\n    node.type === 'TSBooleanKeyword' ||\n    node.type === 'TSConditionalType' ||\n    node.type === 'TSConstructorType' ||\n    node.type === 'TSDeclareKeyword' ||\n    node.type === 'TSExportKeyword' ||\n    node.type === 'TSFunctionType' ||\n    node.type === 'TSImportType' ||\n    node.type === 'TSIndexedAccessType' ||\n    node.type === 'TSInferType' ||\n    node.type === 'TSIntersectionType' ||\n    node.type === 'TSIntrinsicKeyword' ||\n    node.type === 'TSLiteralType' ||\n    node.type === 'TSMappedType' ||\n    node.type === 'TSNamedTupleMember' ||\n    node.type === 'TSNeverKeyword' ||\n    node.type === 'TSNullKeyword' ||\n    node.type === 'TSNumberKeyword' ||\n    node.type === 'TSObjectKeyword' ||\n    node.type === 'TSOptionalType' ||\n    node.type === 'TSQualifiedName' ||\n    node.type === 'TSPrivateKeyword' ||\n    node.type === 'TSProtectedKeyword' ||\n    node.type === 'TSPublicKeyword' ||\n    node.type === 'TSReadonlyKeyword' ||\n    node.type === 'TSRestType' ||\n    node.type === 'TSStaticKeyword' ||\n    node.type === 'TSStringKeyword' ||\n    node.type === 'TSSymbolKeyword' ||\n    node.type === 'TSTemplateLiteralType' ||\n    node.type === 'TSThisType' ||\n    node.type === 'TSTupleType' ||\n    node.type === 'TSTypeLiteral' ||\n    node.type === 'TSTypeOperator' ||\n    node.type === 'TSTypePredicate' ||\n    node.type === 'TSTypeQuery' ||\n    node.type === 'TSTypeReference' ||\n    node.type === 'TSUndefinedKeyword' ||\n    node.type === 'TSUnionType' ||\n    node.type === 'TSUnknownKeyword' ||\n    node.type === 'TSVoidKeyword'\n  ) {\n    /** @type {TypeNode['type']} for type check */\n    const type = node.type\n    noop(type)\n    return true\n  }\n  /** @type {Exclude<ASTNode['type'], TypeNode['type']>} for type check */\n  const type = node.type\n  noop(type)\n  return false\n}\n\n/**\n * @param {TSESTreeTypeNode|TSESTreeTSInterfaceBody} node\n * @returns {node is TSESTreeTSInterfaceBody}\n */\nfunction isTSInterfaceBody(node) {\n  return node.type === 'TSInterfaceBody'\n}\n/**\n * @param {TSESTreeTypeNode} node\n * @returns {node is TSESTreeTSTypeLiteral}\n */\nfunction isTSTypeLiteral(node) {\n  return node.type === 'TSTypeLiteral'\n}\n/**\n * @param {TSESTreeTypeNode} node\n * @returns {node is TSESTreeTSFunctionType}\n */\nfunction isTSFunctionType(node) {\n  return node.type === 'TSFunctionType'\n}\n/**\n * @param {TSESTreeTypeNode} node\n * @returns {node is TSESTreeTSTypeLiteral | TSESTreeTSFunctionType}\n */\nfunction isTSTypeLiteralOrTSFunctionType(node) {\n  return isTSTypeLiteral(node) || isTSFunctionType(node)\n}\n\n/**\n * @see https://github.com/vuejs/vue-next/blob/253ca2729d808fc051215876aa4af986e4caa43c/packages/compiler-sfc/src/compileScript.ts#L1512\n * @param {RuleContext} context The ESLint rule context object.\n * @param {TSESTreeTSTypeLiteral | TSESTreeTSInterfaceBody} node\n * @returns {IterableIterator<ComponentTypeProp | ComponentUnknownProp>}\n */\nfunction* extractRuntimeProps(context, node) {\n  const members = node.type === 'TSTypeLiteral' ? node.members : node.body\n  for (const member of members) {\n    if (\n      member.type === 'TSPropertySignature' ||\n      member.type === 'TSMethodSignature'\n    ) {\n      if (member.key.type !== 'Identifier' && member.key.type !== 'Literal') {\n        yield {\n          type: 'unknown',\n          propName: null,\n          node: /** @type {Expression} */ (member.key)\n        }\n        continue\n      }\n      /** @type {string[]|undefined} */\n      let types\n      if (member.type === 'TSMethodSignature') {\n        types = ['Function']\n      } else if (member.typeAnnotation) {\n        types = inferRuntimeType(context, member.typeAnnotation.typeAnnotation)\n      }\n      yield {\n        type: 'type',\n        key: /** @type {Identifier | Literal} */ (member.key),\n        propName:\n          member.key.type === 'Identifier'\n            ? member.key.name\n            : `${member.key.value}`,\n        node: /** @type {TSPropertySignature | TSMethodSignature} */ (member),\n\n        required: !member.optional,\n        types: types || [`null`]\n      }\n    }\n  }\n}\n\n/**\n * @param {TSESTreeTSTypeLiteral | TSESTreeTSInterfaceBody | TSESTreeTSFunctionType} node\n * @returns {IterableIterator<ComponentTypeEmit | ComponentUnknownEmit>}\n */\nfunction* extractRuntimeEmits(node) {\n  if (node.type === 'TSFunctionType') {\n    yield* extractEventNames(\n      node.params[0],\n      /** @type {TSFunctionType} */ (node)\n    )\n    return\n  }\n  const members = node.type === 'TSTypeLiteral' ? node.members : node.body\n  for (const member of members) {\n    if (member.type === 'TSCallSignatureDeclaration') {\n      yield* extractEventNames(\n        member.params[0],\n        /** @type {TSCallSignatureDeclaration} */ (member)\n      )\n    } else if (\n      member.type === 'TSPropertySignature' ||\n      member.type === 'TSMethodSignature'\n    ) {\n      if (member.key.type !== 'Identifier' && member.key.type !== 'Literal') {\n        yield {\n          type: 'unknown',\n          emitName: null,\n          node: /** @type {Expression} */ (member.key)\n        }\n        continue\n      }\n      yield {\n        type: 'type',\n        key: /** @type {Identifier | Literal} */ (member.key),\n        emitName:\n          member.key.type === 'Identifier'\n            ? member.key.name\n            : `${member.key.value}`,\n        node: /** @type {TSPropertySignature | TSMethodSignature} */ (member)\n      }\n    }\n  }\n}\n\n/**\n * @param {TSESTreeParameter} eventName\n * @param {TSCallSignatureDeclaration | TSFunctionType} member\n * @returns {IterableIterator<ComponentTypeEmit>}\n */\nfunction* extractEventNames(eventName, member) {\n  if (\n    eventName &&\n    eventName.type === 'Identifier' &&\n    eventName.typeAnnotation &&\n    eventName.typeAnnotation.type === 'TSTypeAnnotation'\n  ) {\n    const typeNode = eventName.typeAnnotation.typeAnnotation\n    if (\n      typeNode.type === 'TSLiteralType' &&\n      typeNode.literal.type === 'Literal'\n    ) {\n      const emitName = String(typeNode.literal.value)\n      yield {\n        type: 'type',\n        key: /** @type {TSLiteralType} */ (typeNode),\n        emitName,\n        node: member\n      }\n    } else if (typeNode.type === 'TSUnionType') {\n      for (const t of typeNode.types) {\n        if (t.type === 'TSLiteralType' && t.literal.type === 'Literal') {\n          const emitName = String(t.literal.value)\n          yield {\n            type: 'type',\n            key: /** @type {TSLiteralType} */ (t),\n            emitName,\n            node: member\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {RuleContext} context The ESLint rule context object.\n * @param {TSESTreeTypeNode} node\n * @returns {(TSESTreeTypeNode|TSESTreeTSInterfaceBody)[]}\n */\nfunction flattenTypeNodes(context, node) {\n  /**\n   * @typedef {object} TraversedData\n   * @property {Set<TSESTreeTypeNode|TSESTreeTSInterfaceBody>} nodes\n   * @property {boolean} finished\n   */\n  /** @type {Map<TSESTreeTypeNode,TraversedData>} */\n  const traversed = new Map()\n\n  return [...flattenImpl(node)]\n  /**\n   * @param {TSESTreeTypeNode} node\n   * @returns {Iterable<TSESTreeTypeNode|TSESTreeTSInterfaceBody>}\n   */\n  function* flattenImpl(node) {\n    if (node.type === 'TSUnionType' || node.type === 'TSIntersectionType') {\n      for (const typeNode of node.types) {\n        yield* flattenImpl(typeNode)\n      }\n      return\n    }\n    if (\n      node.type === 'TSTypeReference' &&\n      node.typeName.type === 'Identifier'\n    ) {\n      const refName = node.typeName.name\n      const variable = findVariable(\n        getScope(context, /** @type {any} */ (node)),\n        refName\n      )\n      if (variable && variable.defs.length === 1) {\n        const defNode = /** @type {TSESTreeNode} */ (variable.defs[0].node)\n        if (defNode.type === 'TSInterfaceDeclaration') {\n          yield defNode.body\n          return\n        } else if (defNode.type === 'TSTypeAliasDeclaration') {\n          const typeAnnotation = defNode.typeAnnotation\n          let traversedData = traversed.get(typeAnnotation)\n          if (traversedData) {\n            const copy = [...traversedData.nodes]\n            yield* copy\n            if (!traversedData.finished) {\n              // Include the node because it will probably be referenced recursively.\n              yield typeAnnotation\n            }\n            return\n          }\n          traversedData = { nodes: new Set(), finished: false }\n          traversed.set(typeAnnotation, traversedData)\n          for (const e of flattenImpl(typeAnnotation)) {\n            traversedData.nodes.add(e)\n          }\n          traversedData.finished = true\n          yield* traversedData.nodes\n          return\n        }\n      }\n    }\n    yield node\n  }\n}\n\n/**\n * @param {RuleContext} context The ESLint rule context object.\n * @param {TSESTreeTypeNode} node\n * @param {Set<TSESTreeTypeNode>} [checked]\n * @returns {string[]}\n */\nfunction inferRuntimeType(context, node, checked = new Set()) {\n  switch (node.type) {\n    case 'TSStringKeyword':\n    case 'TSTemplateLiteralType': {\n      return ['String']\n    }\n    case 'TSNumberKeyword': {\n      return ['Number']\n    }\n    case 'TSBooleanKeyword': {\n      return ['Boolean']\n    }\n    case 'TSObjectKeyword': {\n      return ['Object']\n    }\n    case 'TSTypeLiteral': {\n      return inferTypeLiteralType(node)\n    }\n    case 'TSFunctionType': {\n      return ['Function']\n    }\n    case 'TSArrayType':\n    case 'TSTupleType': {\n      return ['Array']\n    }\n    case 'TSSymbolKeyword': {\n      return ['Symbol']\n    }\n\n    case 'TSLiteralType': {\n      if (node.literal.type === 'Literal') {\n        switch (typeof node.literal.value) {\n          case 'boolean': {\n            return ['Boolean']\n          }\n          case 'string': {\n            return ['String']\n          }\n          case 'number':\n          case 'bigint': {\n            return ['Number']\n          }\n        }\n        if (node.literal.value instanceof RegExp) {\n          return ['RegExp']\n        }\n      }\n      return inferRuntimeTypeFromTypeNode(\n        context,\n        /** @type {TypeNode} */ (node)\n      )\n    }\n    case 'TSTypeReference': {\n      if (node.typeName.type === 'Identifier') {\n        const variable = findVariable(\n          getScope(context, /** @type {any} */ (node)),\n          node.typeName.name\n        )\n        if (variable && variable.defs.length === 1) {\n          const defNode = /** @type {TSESTreeNode} */ (variable.defs[0].node)\n          if (defNode.type === 'TSInterfaceDeclaration') {\n            return [`Object`]\n          }\n          if (defNode.type === 'TSTypeAliasDeclaration') {\n            const typeAnnotation = defNode.typeAnnotation\n            if (!checked.has(typeAnnotation)) {\n              checked.add(typeAnnotation)\n              return inferRuntimeType(context, typeAnnotation, checked)\n            }\n          }\n          if (defNode.type === 'TSEnumDeclaration') {\n            return inferEnumType(context, defNode)\n          }\n        }\n        for (const name of [\n          node.typeName.name,\n          ...(node.typeName.name.startsWith('Readonly')\n            ? [node.typeName.name.slice(8)]\n            : [])\n        ]) {\n          switch (name) {\n            case 'Array':\n            case 'Function':\n            case 'Object':\n            case 'Set':\n            case 'Map':\n            case 'WeakSet':\n            case 'WeakMap':\n            case 'Date': {\n              return [name]\n            }\n          }\n        }\n\n        switch (node.typeName.name) {\n          case 'Record':\n          case 'Partial':\n          case 'Readonly':\n          case 'Pick':\n          case 'Omit':\n          case 'Required':\n          case 'InstanceType': {\n            return ['Object']\n          }\n          case 'Uppercase':\n          case 'Lowercase':\n          case 'Capitalize':\n          case 'Uncapitalize': {\n            return ['String']\n          }\n          case 'Parameters':\n          case 'ConstructorParameters': {\n            return ['Array']\n          }\n          case 'NonNullable': {\n            const typeArguments =\n              'typeArguments' in node\n                ? node.typeArguments\n                : /** @type {any} typescript-eslint v5 */ (node).typeParameters\n            if (typeArguments && typeArguments.params[0]) {\n              return inferRuntimeType(\n                context,\n                typeArguments.params[0],\n                checked\n              ).filter((t) => t !== 'null')\n            }\n            break\n          }\n          case 'Extract': {\n            const typeArguments =\n              'typeArguments' in node\n                ? node.typeArguments\n                : /** @type {any} typescript-eslint v5 */ (node).typeParameters\n            if (typeArguments && typeArguments.params[1]) {\n              return inferRuntimeType(context, typeArguments.params[1], checked)\n            }\n            break\n          }\n          case 'Exclude':\n          case 'OmitThisParameter': {\n            const typeArguments =\n              'typeArguments' in node\n                ? node.typeArguments\n                : /** @type {any} typescript-eslint v5 */ (node).typeParameters\n            if (typeArguments && typeArguments.params[0]) {\n              return inferRuntimeType(context, typeArguments.params[0], checked)\n            }\n            break\n          }\n        }\n      }\n      return inferRuntimeTypeFromTypeNode(\n        context,\n        /** @type {TypeNode} */ (node)\n      )\n    }\n\n    case 'TSUnionType':\n    case 'TSIntersectionType': {\n      return inferUnionType(node)\n    }\n\n    default: {\n      return inferRuntimeTypeFromTypeNode(\n        context,\n        /** @type {TypeNode} */ (node)\n      )\n    }\n  }\n\n  /**\n   * @param {import('@typescript-eslint/types').TSESTree.TSUnionType|import('@typescript-eslint/types').TSESTree.TSIntersectionType} node\n   * @returns {string[]}\n   */\n  function inferUnionType(node) {\n    const types = new Set()\n    for (const t of node.types) {\n      for (const tt of inferRuntimeType(context, t, checked)) {\n        types.add(tt)\n      }\n    }\n    return [...types]\n  }\n}\n\n/**\n * @param {import('@typescript-eslint/types').TSESTree.TSTypeLiteral} node\n * @returns {string[]}\n */\nfunction inferTypeLiteralType(node) {\n  const types = new Set()\n  for (const m of node.members) {\n    switch (m.type) {\n      case 'TSCallSignatureDeclaration':\n      case 'TSConstructSignatureDeclaration': {\n        types.add('Function')\n        break\n      }\n      default: {\n        types.add('Object')\n      }\n    }\n  }\n  return types.size > 0 ? [...types] : ['Object']\n}\n/**\n * @param {RuleContext} context The ESLint rule context object.\n * @param {import('@typescript-eslint/types').TSESTree.TSEnumDeclaration} node\n * @returns {string[]}\n */\nfunction inferEnumType(context, node) {\n  const types = new Set()\n  for (const m of node.members) {\n    if (m.initializer) {\n      if (m.initializer.type === 'Literal') {\n        switch (typeof m.initializer.value) {\n          case 'string': {\n            types.add('String')\n            break\n          }\n          case 'number':\n          case 'bigint': {\n            // Now it's a syntax error.\n            types.add('Number')\n            break\n          }\n          case 'boolean': {\n            // Now it's a syntax error.\n            types.add('Boolean')\n            break\n          }\n        }\n      } else {\n        for (const type of inferRuntimeTypeFromTypeNode(\n          context,\n          /** @type {Expression} */ (m.initializer)\n        )) {\n          types.add(type)\n        }\n      }\n    }\n  }\n  return types.size > 0 ? [...types] : ['Number']\n}\n"],
  "mappings": "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B;IACA;AC1CA,QAAM,eACF,OAAO,eAAe,cAChB,aACA,OAAO,SAAS,cAChB,OACA,OAAO,WAAW,cAClB,SACA,OAAO,WAAW,cAClB,SACA,CAAA;AAEV,QAAM,eAAe,OAAO;MACxB,oBAAI,IAAI;QACJ;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;MACR,CAAK;IACL;AACA,QAAM,cAAc,IAAI;MACpB;QACI,MAAM;QACN,MAAM;QACN,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,OAAO,WAAW,aAAa,SAAS;QACxC;QACA;QACA,KAAK;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,IAAI,UAAU;QACd,IAAI,UAAU;QACd,IAAI,UAAU;QACd,IAAI,UAAU;QACd,IAAI,UAAU;QACd,GAAG,OAAO,oBAAoB,IAAI,EAC7B,OAAO,CAAC,MAAM,MAAM,QAAQ,EAC5B,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC,EAClB,OAAO,CAAC,MAAM,OAAO,MAAM,UAAU;QAC1C;QACA,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO,UAAU;QACjB,OAAO,UAAU;QACjB,OAAO,UAAU;QACjB,OAAO,UAAU;QACjB;QACA,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP;QA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",
  "names": ["getKeys", "KEYS", "index", "type", "type", "node"]
}
